---
title: "Mening_CNA_Arm_Percent_Master"
author: "Ruchit Patel"
date: "2023-08-16"
output: html_document
---

```{r}
library(RColorBrewer)
library(ggplot2)
library(ggridges)
library(forcats)
library(fmsb)
library(forestplot)
library(dplyr)
library(openxlsx)
library(stringr)
library(scales)
library(tidyr)
library(gridExtra)
library(cowplot)
library(pracma)
library(networkD3)
library(survival)
library(broom)
library(survminer)

path <- 'Insert path here'
file_name <- "Insert name of meningioma seg file here, file should be microarray data filtered with event calls generated"
genome_file_name <- 'genome_reference_GRCh37.xlsx'
arm_file_name <- 'arm_reference_GRCh37.xlsx'
normal_file_name <- 'nat_rev_gen_human_normal_cnv.xlsx'
file_path <- file.path(path, file_name)
genome_reference_file_path <- file.path(path, genome_file_name)
arm_reference_file_path <- file.path(path, arm_file_name)
normal_reference_file_path <- file.path(path, normal_file_name)

#Import meningioma master seg file and genome size file
mening_seg <- read.table(file_path, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
genome_size <- read.xlsx(genome_reference_file_path)
arm_size <- read.xlsx(arm_reference_file_path)
```

```{r}
#Calculate how much of the chromosome was affected - contiguous loss (whole chr)
mening_seg$Start <- as.numeric(mening_seg$Start)
mening_seg$End <- as.numeric(mening_seg$End)

mening_seg$size <- mening_seg$End - mening_seg$Start
combined_mening_seg <- mening_seg %>% left_join(genome_size, by = "Chr")
combined_mening_seg <- combined_mening_seg %>% mutate(pct_affected = (size/size_bp)*100)
combined_mening_seg <- combined_mening_seg %>% mutate(pct_assay_affect = (size/size_assay)*100)
combined_mening_seg <- combined_mening_seg %>% filter(Sample != "Sample")
```

```{r}
#We need to first remove LOH calls and then remove duplications.

#Remove LOH calls
combined_mening_seg <- combined_mening_seg %>% filter(Event != "LOH")

#First we convert events into loss or gain
combined_mening_seg_relabeled <- combined_mening_seg %>% mutate(Event = recode(Event,
                                                                               "CN Loss" = "loss",
                                                                               "CN Gain" = "gain",
                                                                               "Homozygous Copy Loss" = "loss",
                                                                               "High Copy Gain" = "gain",
                                                                               .default = Event))


#Next we remove duplicates
combined_mening_seg_unique <- combined_mening_seg_relabeled %>% distinct()

```

```{r}
#We now have to process these files to ensure that contiguous calls are generated correctly: need to do some data cleanup
combined_mening_seg_unique <- combined_mening_seg_unique %>% mutate(Arm = substr(Cytoband, 1, 1), Arm_combined = str_extract_all(Cytoband, "[a-zA-Z]+") %>% lapply(paste, collapse = " "))
combined_mening_seg_unique$Arm_combined <- gsub(" ", "", combined_mening_seg_unique$Arm_combined)

combined_mening_cleanup <- combined_mening_seg_unique %>% group_by(Sample, Chr, Arm, Event) %>% filter(n() > 1) %>% ungroup() 
combined_mening_seg_filtered <- anti_join(combined_mening_seg_unique, combined_mening_cleanup)

#First clean samples that have the same Chr, Arm, Event with the same starting CNV position
grouped_data <- combined_mening_cleanup %>% group_by(Sample, Chr, Arm, Event)
matching_start_rows <- combined_mening_cleanup %>% group_by(Sample, Chr, Arm, Event, Start) %>% filter(n() > 1) %>% ungroup()
combined_mening_cleanup <- anti_join(combined_mening_cleanup, matching_start_rows)

matching_start_rows <- matching_start_rows %>% group_by(Sample, Chr, Arm, Event, Start) %>% top_n(1, wt = desc(-pct_affected)) %>% ungroup()
combined_mening_cleanup <- bind_rows(combined_mening_cleanup, matching_start_rows)

#Next clean samples that have the same Chr, Arm, Event with the same ending CNV position
grouped_data <- combined_mening_cleanup %>% group_by(Sample, Chr, Arm, Event)
matching_end_rows <- combined_mening_cleanup %>% group_by(Sample, Chr, Arm, Event, End) %>% filter(n() > 1) %>% ungroup()
combined_mening_cleanup <- anti_join(combined_mening_cleanup, matching_end_rows)

matching_end_rows <- matching_end_rows %>% group_by(Sample, Chr, Arm, Event, End) %>% top_n(1, wt = desc(-pct_affected)) %>% ungroup()
combined_mening_cleanup <- bind_rows(combined_mening_cleanup, matching_end_rows)

#Next, handle samples where the end point is the same as the start point - e.g, these were defined as separate fragments but really are combined together in space
combined_mening_cleanup <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start)
matching_start_end_rows <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start) %>% group_by(Sample, Chr, Arm, Event) %>% filter(lag(End) == Start | lead(Start) == End) %>%
  ungroup()
combined_mening_cleanup <- anti_join(combined_mening_cleanup, matching_start_end_rows)

matching_start_end_rows_processed <- matching_start_end_rows %>% group_by(Sample, Chr, Arm, Event) %>% summarise(Start = first(Start), End = last(End), size = sum(size), pct_affected = sum(pct_affected), Probes = first(Probes), Probe.Median = first(Probe.Median), Cytoband = first(Cytoband), size_bp = first(size_bp), arms_division = first(arms_division), Arm_combined = first(Arm_combined))

matching_start_end_rows_processed <- matching_start_end_rows_processed %>% select(Sample, Chr, Start, End, Probes, Probe.Median, Event, Cytoband, size, size_bp, arms_division, pct_affected, Arm, Arm_combined)
combined_mening_cleanup <- bind_rows(combined_mening_cleanup, matching_start_end_rows_processed)

#Handle samples in which there was overlap between start and end points
combined_mening_cleanup <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start)
overlapping_rows <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start) %>% group_by(Sample, Chr, Arm, Event) %>% filter(lag(End) > Start | lead(Start) < End) %>%
  ungroup()
combined_mening_cleanup <- anti_join(combined_mening_cleanup, overlapping_rows)

overlapping_rows <- overlapping_rows %>% group_by(Sample, Chr, Arm, Event) %>% top_n(1, wt = desc(-pct_affected)) %>% ungroup()
combined_mening_cleanup <- bind_rows(combined_mening_cleanup, overlapping_rows)

#Need to clean nested reads
combined_mening_cleanup <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start)

grouped_data <- combined_mening_cleanup %>% arrange(Sample, Chr, Arm, Event, Start) %>% group_by(Sample, Chr, Arm, Event)

subset_rows <- grouped_data %>% filter(Start == min(Start) & End == max(End))

group_columns <- c("Sample", "Arm", "Chr", "Event")
matched_rows <- combined_mening_cleanup %>% semi_join(subset_rows, by = group_columns)
isolated_rows <- anti_join(matched_rows, subset_rows)

combined_mening_cleanup <- anti_join(combined_mening_cleanup, isolated_rows)

#Manually cleaning 1 sample with difficult nested read to clean

combined_mening_cleanup_vals <- combined_mening_cleanup %>% filter((Sample == "MN_911" & Chr == "chr7" & Arm == "p" & Event == "loss" & Start == 17580193))
combined_mening_cleanup <- anti_join(combined_mening_cleanup, combined_mening_cleanup_vals)



#Return the dataset to its full form
combined_mening_seg_unique <- bind_rows(combined_mening_cleanup, combined_mening_seg_filtered)



```


```{r}
#First figure out which arm/arms are affected - this is to account for alterations that stretch across multiple arms
combined_mening_seg_arm <- combined_mening_seg_unique
combined_mening_seg_arm$Arm_combined <- gsub(" ", "", combined_mening_seg_arm$Arm_combined)
combined_mening_seg_arm <- combined_mening_seg_arm %>% mutate(Arm = ifelse(Arm_combined %in% c("pq", "qp"), "both", Arm))

#Confirming here that in situations where the cytoband report said p AND q, it was infact both arms. If only isolated to one arm, fix that annotation
combined_mening_seg_arm <- combined_mening_seg_arm %>% mutate(Arm_checked = Arm)
combined_mening_seg_arm <- combined_mening_seg_arm %>% mutate(Arm_checked = ifelse(Arm == "both" & End < arms_division, "p", Arm_checked))

#In situations when both p and q were affected, we need to figure out how much p and how much q and then add that back into the combined file
both_pq_altered <- combined_mening_seg_arm %>% filter(Arm_checked == "both")

#Remove instances of both pq loss in the combined mening seg file
combined_mening_seg_arm <- combined_mening_seg_arm %>% filter(Arm_checked != "both")

#Process p and q arms separately when both are affected
both_pq_duplicated <- both_pq_altered %>% bind_rows(mutate(both_pq_altered, Arm_checked = "p"), mutate(both_pq_altered, Arm_checked = "q"))
both_pq_duplicated <- both_pq_duplicated %>% filter(Arm_checked != "both")

both_pq_duplicated <- both_pq_duplicated %>% mutate(size = ifelse(Arm_checked == "p", arms_division - Start, ifelse(Arm_checked == "q", End - arms_division, size)))

#Merge back with combined mening_seg_arm
combined_mening_seg_arm <- bind_rows(combined_mening_seg_arm, both_pq_duplicated)
combined_mening_seg_arm <- combined_mening_seg_arm %>% arrange(Sample, Chr)

#Add column of arm sizes
arm_size$Arm_checked <- arm_size$Arm
arm_size_shortened <- arm_size %>% select(Chr, Arm_checked, size_arm)
combined_mening_seg_arm <- left_join(combined_mening_seg_arm, arm_size_shortened, by = c("Chr", "Arm_checked"))

#Calculate how much of the arm was affected
combined_mening_seg_arm <- combined_mening_seg_arm %>% mutate(arm_pct_affected = (size/size_arm)*100)



combined_mening_seg_arm_relabeled <- combined_mening_seg_arm %>% mutate(Event = recode(Event,
                                                                               "CN Loss" = "loss",
                                                                               "CN Gain" = "gain",
                                                                               "Homozygous Copy Loss" = "loss",
                                                                               "High Copy Gain" = "gain",
                                                                               .default = Event))

combined_mening_seg_arm_unique <- combined_mening_seg_arm_relabeled %>% distinct()
```


```{r}
#Filter out CNV events that were found in normal humans. Using Nat Rev Gen 2015 Stringent CNV file to do filtering (Zarrei et al., 2015)
normal_cnvs <- read.xlsx(normal_reference_file_path)

#Filter out in the combined_mening_seg_arm_unique file
rows_to_remove_total <- data.frame()

# Loop through each row in combined_mening_seg_arm_unique
for (i in 1:nrow(combined_mening_seg_unique)) {
  # Filter rows in normal_cnvs based on the conditions
  matching_rows <- normal_cnvs %>%
    filter(
      chr == combined_mening_seg_unique$Chr[i],
      type == combined_mening_seg_unique$Event[i],
      start <= combined_mening_seg_unique$Start[i],
      end >= combined_mening_seg_unique$End[i]
    )
  
  # If there are matching rows, add them to rows_to_remove
  if (nrow(matching_rows) > 0) {
    rows_to_remove_total <- bind_rows(rows_to_remove_total, combined_mening_seg_unique[i, ])
  }
}

combined_mening_seg_unique <- anti_join(combined_mening_seg_unique, rows_to_remove_total)


#Filter out in the combined_mening_seg_arm_unique file
rows_to_remove <- data.frame()

# Loop through each row in combined_mening_seg_arm_unique
for (i in 1:nrow(combined_mening_seg_arm_unique)) {
  # Filter rows in normal_cnvs based on the conditions
  matching_rows <- normal_cnvs %>%
    filter(
      chr == combined_mening_seg_arm_unique$Chr[i],
      type == combined_mening_seg_arm_unique$Event[i],
      start <= combined_mening_seg_arm_unique$Start[i],
      end >= combined_mening_seg_arm_unique$End[i]
    )
  
  # If there are matching rows, add them to rows_to_remove
  if (nrow(matching_rows) > 0) {
    rows_to_remove <- bind_rows(rows_to_remove, combined_mening_seg_arm_unique[i, ])
  }
}

combined_mening_seg_arm_unique <- anti_join(combined_mening_seg_arm_unique, rows_to_remove)

```

```{r}
#Now that we've created data sheets for whole choromsome and arms that are contiguous, we can calculate non-contiguous loss for chromosomes and arms

#Calculate non-contiguous loss (whole chr)
combined_mening_seg_unique <- combined_mening_seg_unique %>% mutate(Arm_checked = if_else(Arm_combined == "pp", "p", if_else(Arm_combined == "qq", "q", Arm_combined)))

#Filter out 21p events if recorded - should not be reported
combined_mening_seg_unique <- combined_mening_seg_unique %>% filter(!(Chr == 21 & Arm_checked == "p"))

noncont_mening_seg_unique <- combined_mening_seg_unique %>% group_by(Sample, Chr, Event) %>% summarize(total_pct = sum(pct_affected, na.rm = TRUE), total_pct_assay = sum(pct_assay_affect, na.rm = TRUE), total_values_summed = n(), total_arm_bp = sum(size, na.rm = TRUE), p_only = if_else(all(Arm_checked == "p"), 1, 0), q_only = if_else(all(Arm_checked == "q"), 1, 0), pq_both = if_else(p_only == 0 & q_only == 0, 1, 0)) %>% ungroup()

#Calculate non-contiguous loss (per arm)

#Filter out 21p events - should not be reported
combined_mening_seg_arm_unique <- combined_mening_seg_arm_unique %>% filter(!(Chr == 21 & Arm_checked == "p"))

noncont_mening_seg_arm_unique <- combined_mening_seg_arm_unique %>% group_by(Sample, Chr, Arm_checked, Event) %>% summarize(total_arm_pct = sum(arm_pct_affected, na.rm = TRUE), total_values_summed = n(), total_arm_bp = sum(size, na.rm = TRUE)) %>% ungroup()
```


```{r, echo=FALSE}
#Plotting Whole Chromsome Gain/Loss (Percentage)
#Convert Chr columns to numeric only
noncont_mening_seg_unique$Chr <- sub("^chr", "", noncont_mening_seg_unique$Chr)
noncont_mening_seg_unique$Chr <- as.numeric(noncont_mening_seg_unique$Chr)

combined_mening_seg_unique$Chr <- sub("^chr", "", combined_mening_seg_unique$Chr)
combined_mening_seg_unique$Chr <- as.numeric(combined_mening_seg_unique$Chr)

#Address any small decimals over 100
combined_mening_seg_unique <- combined_mening_seg_unique %>% mutate(pct_affected = ifelse(pct_affected > 100, 100, pct_affected))
noncont_mening_seg_unique <- noncont_mening_seg_unique %>% mutate(total_pct = ifelse(total_pct > 100, 100, total_pct))

#Subset into loss and gain
noncont_loss_samples <- subset(noncont_mening_seg_unique, Event == "loss")
noncont_gain_samples <- subset(noncont_mening_seg_unique, Event == "gain")
cont_loss_samples <- subset(combined_mening_seg_unique, Event == "loss")
cont_gain_samples <- subset(combined_mening_seg_unique, Event == "gain")

noncont_loss_plot <- ggplot(noncont_loss_samples, aes(x = total_pct_assay, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")

noncont_gain_plot <- ggplot(noncont_gain_samples, aes(x = total_pct_assay, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")

cont_loss_plot <- ggplot(cont_loss_samples, aes(x = pct_affected, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10), limits=c(0,100)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")

cont_gain_plot <- ggplot(cont_gain_samples, aes(x = pct_affected, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")
```

```{r, echo=FALSE}
#Plotting Whole Chromsome Gain/Loss (Absolute Size)
#Convert Chr columns to numeric only
noncont_mening_seg_unique$Chr <- sub("^chr", "", noncont_mening_seg_unique$Chr)
noncont_mening_seg_unique$Chr <- as.numeric(noncont_mening_seg_unique$Chr)

combined_mening_seg_unique$Chr <- sub("^chr", "", combined_mening_seg_unique$Chr)
combined_mening_seg_unique$Chr <- as.numeric(combined_mening_seg_unique$Chr)

#Calculate absolute size gained/lost in megabases (1,000,000 bases)
combined_mening_seg_unique <- combined_mening_seg_unique %>% mutate(size_mb = size / 1000000)
noncont_mening_seg_unique <- noncont_mening_seg_unique %>% mutate(size_mb = total_arm_bp / 1000000)

#Subset into loss and gain
noncont_loss_samples <- subset(noncont_mening_seg_unique, Event == "loss")
noncont_gain_samples <- subset(noncont_mening_seg_unique, Event == "gain")
cont_loss_samples <- subset(combined_mening_seg_unique, Event == "loss")
cont_gain_samples <- subset(combined_mening_seg_unique, Event == "gain")

noncont_loss_plot_bp <- ggplot(noncont_loss_samples, aes(x = size_mb, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 250, by = 50), limits = c(0,250)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")

noncont_gain_plot_bp <- ggplot(noncont_gain_samples, aes(x = size_mb, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 250, by = 50), limits = c(0,250)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")

cont_loss_plot_bp <- ggplot(cont_loss_samples, aes(x = size_mb, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 200, by = 50), limits = c(0,200))  +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")

cont_gain_plot_bp <- ggplot(cont_gain_samples, aes(x = size_mb, y = reorder(Chr, -as.numeric(Chr)))) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 200, by = 50), limits = c(0,200))  +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")
```


```{r}
#Plotting Arm Gain/Loss (Percentage)
noncont_mening_seg_arm_unique$Chr <- sub("^chr", "", noncont_mening_seg_arm_unique$Chr)
noncont_mening_seg_arm_unique$Chr <- as.numeric(noncont_mening_seg_arm_unique$Chr)

combined_mening_seg_arm_unique$Chr <- sub("^chr", "", combined_mening_seg_arm_unique$Chr)
combined_mening_seg_arm_unique$Chr <- as.numeric(combined_mening_seg_arm_unique$Chr)

#Address any small decimals over 100
combined_mening_seg_arm_unique <- combined_mening_seg_arm_unique %>% mutate(arm_pct_affected = ifelse(arm_pct_affected > 100, 100, arm_pct_affected))
noncont_mening_seg_arm_unique <- noncont_mening_seg_arm_unique %>% mutate(total_arm_pct = ifelse(total_arm_pct > 100, 100, total_arm_pct))

#Subset into loss and gain
noncont_arm_loss_samples <- subset(noncont_mening_seg_arm_unique, Event == "loss")
noncont_arm_gain_samples <- subset(noncont_mening_seg_arm_unique, Event == "gain")
cont_arm_loss_samples <- subset(combined_mening_seg_arm_unique, Event == "loss")
cont_arm_gain_samples <- subset(combined_mening_seg_arm_unique, Event == "gain")

#Prepare data for plotting
plot_levels <- c('1p', '1q', '2p', '2q', '3p', '3q', '4p', '4q','5p', '5q', '6p', '6q','7p', '7q', '8p', '8q','9p', '9q', '10p', '10q','11p', '11q', '12p', '12q', '13q', '14q','15q', '16p', '16q','17p', '17q', '18p', '18q','19p', '19q', '20p', '20q', '21p', '21q', '22q')
plot_levels <- rev(plot_levels)

noncont_arm_loss_samples$Chr_Arm <- paste(noncont_arm_loss_samples$Chr, noncont_arm_loss_samples$Arm_checked, sep = "")
noncont_arm_gain_samples$Chr_Arm <- paste(noncont_arm_gain_samples$Chr, noncont_arm_gain_samples$Arm_checked, sep = "")
cont_arm_loss_samples$Chr_Arm <- paste(cont_arm_loss_samples$Chr, cont_arm_loss_samples$Arm_checked, sep = "")
cont_arm_gain_samples$Chr_Arm <- paste(cont_arm_gain_samples$Chr, cont_arm_gain_samples$Arm_checked, sep = "")

noncont_arm_loss_samples$Chr_Arm <- factor(noncont_arm_loss_samples$Chr_Arm, levels = plot_levels)
noncont_arm_gain_samples$Chr_Arm <- factor(noncont_arm_gain_samples$Chr_Arm, levels = plot_levels)
cont_arm_loss_samples$Chr_Arm <- factor(cont_arm_loss_samples$Chr_Arm, levels = plot_levels)
cont_arm_gain_samples$Chr_Arm <- factor(cont_arm_gain_samples$Chr_Arm, levels = plot_levels)

#Plot data
noncont_arm_loss_plot <- ggplot(noncont_arm_loss_samples, aes(x = total_arm_pct, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Arm Percentage", y = "Chromosome Arm")

noncont_arm_gain_plot <- ggplot(noncont_arm_gain_samples, aes(x = total_arm_pct, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")

cont_arm_loss_plot <- ggplot(cont_arm_loss_samples, aes(x = arm_pct_affected, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10), limits=c(0,100)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")

cont_arm_gain_plot <- ggplot(cont_arm_gain_samples, aes(x = arm_pct_affected, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 100, by = 10)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Total Percentage", y = "Chromosome")
```


```{r}
#Plotting Arm Gain/Loss (Absolute Number)
noncont_mening_seg_arm_unique$Chr <- sub("^chr", "", noncont_mening_seg_arm_unique$Chr)
noncont_mening_seg_arm_unique$Chr <- as.numeric(noncont_mening_seg_arm_unique$Chr)

combined_mening_seg_arm_unique$Chr <- sub("^chr", "", combined_mening_seg_arm_unique$Chr)
combined_mening_seg_arm_unique$Chr <- as.numeric(combined_mening_seg_arm_unique$Chr)

#Calculate absolute size gained/lost in megabases (1,000,000 bases)
combined_mening_seg_arm_unique <- combined_mening_seg_arm_unique %>% mutate(size_mb = size / 1000000)
noncont_mening_seg_arm_unique <- noncont_mening_seg_arm_unique %>% mutate(size_mb = total_arm_bp / 1000000)

#Subset into loss and gain
noncont_arm_loss_samples <- subset(noncont_mening_seg_arm_unique, Event == "loss")
noncont_arm_gain_samples <- subset(noncont_mening_seg_arm_unique, Event == "gain")
cont_arm_loss_samples <- subset(combined_mening_seg_arm_unique, Event == "loss")
cont_arm_gain_samples <- subset(combined_mening_seg_arm_unique, Event == "gain")

#Prepare data for plotting
plot_levels <- c('1p', '1q', '2p', '2q', '3p', '3q', '4p', '4q','5p', '5q', '6p', '6q','7p', '7q', '8p', '8q','9p', '9q', '10p', '10q','11p', '11q', '12p', '12q', '13q', '14q','15q', '16p', '16q','17p', '17q', '18p', '18q','19p', '19q', '20p', '20q', '21p', '21q', '22q')
plot_levels <- rev(plot_levels)

noncont_arm_loss_samples$Chr_Arm <- paste(noncont_arm_loss_samples$Chr, noncont_arm_loss_samples$Arm_checked, sep = "")
noncont_arm_gain_samples$Chr_Arm <- paste(noncont_arm_gain_samples$Chr, noncont_arm_gain_samples$Arm_checked, sep = "")
cont_arm_loss_samples$Chr_Arm <- paste(cont_arm_loss_samples$Chr, cont_arm_loss_samples$Arm_checked, sep = "")
cont_arm_gain_samples$Chr_Arm <- paste(cont_arm_gain_samples$Chr, cont_arm_gain_samples$Arm_checked, sep = "")

noncont_arm_loss_samples$Chr_Arm <- factor(noncont_arm_loss_samples$Chr_Arm, levels = plot_levels)
noncont_arm_gain_samples$Chr_Arm <- factor(noncont_arm_gain_samples$Chr_Arm, levels = plot_levels)
cont_arm_loss_samples$Chr_Arm <- factor(cont_arm_loss_samples$Chr_Arm, levels = plot_levels)
cont_arm_gain_samples$Chr_Arm <- factor(cont_arm_gain_samples$Chr_Arm, levels = plot_levels)

#Plot data
noncont_arm_loss_plot_bp <- ggplot(noncont_arm_loss_samples, aes(x = size_mb, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 150, by = 25), limits = c(0,150)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome Arm")

noncont_arm_gain_plot_bp <- ggplot(noncont_arm_gain_samples, aes(x = size_mb, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 150, by = 25), limits = c(0,150)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")

cont_arm_loss_plot_bp <- ggplot(cont_arm_loss_samples, aes(x = size_mb, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="deepskyblue3") +
  scale_x_continuous(breaks = seq(0, 150, by = 25), limits = c(0,150)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")

cont_arm_gain_plot_bp <- ggplot(cont_arm_gain_samples, aes(x = size_mb, y = Chr_Arm)) +
  #geom_point(position = position_jitter(width = 0.2), size = 2) +
  geom_jitter(position=position_jitter(0.4), size=0.3, color="firebrick3") +
  scale_x_continuous(breaks = seq(0, 150, by = 25), limits = c(0,150)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(), axis.text = element_text(size=18)) +
  labs(x = "Size (Mb)", y = "Chromosome")
```


```{r}
#Plotting summary arm breakdowns at 5% and 50% thresholds 
plot_levels <- c('1p', '1q', '2p', '2q', '3p', '3q', '4p', '4q','5p', '5q', '6p', '6q','7p', '7q', '8p', '8q','9p', '9q', '10p', '10q','11p', '11q', '12p', '12q', '13q', '14q','15q', '16p', '16q','17p', '17q', '18p', '18q','19p', '19q', '20p', '20q', '21p', '21q', '22q')
plot_levels <- rev(plot_levels)

noncont_arm_loss_5 <- noncont_arm_loss_samples %>% filter(total_arm_pct >= 5)
noncont_arm_gain_5 <- noncont_arm_gain_samples %>% filter(total_arm_pct >= 5)

noncont_arm_loss_50 <- noncont_arm_loss_samples %>% filter(total_arm_pct >= 50)
noncont_arm_gain_50 <- noncont_arm_gain_samples %>% filter(total_arm_pct >= 50)

noncont_arm_loss_5$Chr_Arm <- factor(noncont_arm_loss_5$Chr_Arm, levels = plot_levels)
noncont_arm_gain_5$Chr_Arm <- factor(noncont_arm_gain_5$Chr_Arm, levels = plot_levels)
noncont_arm_loss_50$Chr_Arm <- factor(noncont_arm_loss_50$Chr_Arm, levels = plot_levels)
noncont_arm_gain_50$Chr_Arm <- factor(noncont_arm_gain_50$Chr_Arm, levels = plot_levels)

noncont_arm_loss_5_plot <- ggplot(noncont_arm_loss_5, aes(y = Chr_Arm, fill = Chr_Arm)) + geom_bar(fill = "deepskyblue3") + labs(title = "Frequency of Counts for Each Chr_Arm", x = "Chr_Arm", y = "Count") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) + scale_x_continuous(breaks = seq(0, 620, by = 200), limits=c(0,620))

noncont_arm_gain_5_plot <- ggplot(noncont_arm_gain_5, aes(y = Chr_Arm, fill = Chr_Arm)) + geom_bar(fill = "firebrick3") + labs(title = "Frequency of Counts for Each Chr_Arm", x = "Chr_Arm", y = "Count") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) + scale_x_continuous(breaks = seq(0, 200, by = 50), limits=c(0,200))

#To ensure chr arms with 0 counts are being plotted
new_row_3 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, 
                      total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "21p")

noncont_arm_loss_50 <- rbind(noncont_arm_loss_50, new_row_3)
noncont_arm_loss_50$Chr_Arm <- factor(noncont_arm_loss_50$Chr_Arm, levels = plot_levels)


noncont_arm_loss_50_plot <- ggplot(noncont_arm_loss_50, aes(y = Chr_Arm, fill = Chr_Arm)) + geom_bar(fill = "deepskyblue3") + labs(title = "Frequency of Counts for Each Chr_Arm", x = "Chr_Arm", y = "Count") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) + scale_x_continuous(breaks = seq(0, 600, by = 200), limits=c(0,600))



#To ensure Chr arms with 0 counts are being plotted
new_row <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, 
                      total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "1p")
new_row_2 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, 
                      total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "21p")
# Add the new row to the original dataframe
noncont_arm_gain_50 <- rbind(noncont_arm_gain_50, new_row)
noncont_arm_gain_50 <- rbind(noncont_arm_gain_50, new_row_2)
noncont_arm_gain_50$Chr_Arm <- factor(noncont_arm_gain_50$Chr_Arm, levels = plot_levels)

noncont_arm_gain_50_plot <- ggplot(noncont_arm_gain_50, aes(y = Chr_Arm, fill = Chr_Arm)) + geom_bar(fill = "firebrick3") + labs(title = "Frequency of Counts for Each Chr_Arm", x = "Chr_Arm", y = "Count") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) + scale_x_continuous(breaks = seq(0, 200, by = 50), limits=c(0,200))

```


```{r}
#Get summary stats for each of the groups
summary_stats_noncont_loss <- noncont_loss_samples %>%
  group_by(Chr) %>%
  summarise(
    Median = median(total_pct, na.rm = TRUE),
    Mean = mean(total_pct, na.rm = TRUE),
    Range = max(total_pct, na.rm = TRUE) - min(total_pct, na.rm = TRUE)
  )

print(summary_stats_noncont_loss)

summary_stats_noncont_gain <- noncont_gain_samples %>%
  group_by(Chr) %>%
  summarise(
    Median = median(total_pct, na.rm = TRUE),
    Mean = mean(total_pct, na.rm = TRUE),
    Range = max(total_pct, na.rm = TRUE) - min(total_pct, na.rm = TRUE)
  )

print(summary_stats_noncont_gain)


```

```{r}
#Create histogram of # of fragments and # on each arm for noncont gain/loss
#By arm, number of fragments lost
noncont_arm_loss_samples_histo <- noncont_arm_loss_samples %>%  mutate(bin = cut(total_values_summed, breaks = c(0, 1, 2, 3, 4, Inf), labels = c("1", "2", "3", "4", "5+")))

chr_arm_value <- "20q"
subset_data <- subset(noncont_arm_loss_samples_histo, Chr_Arm == chr_arm_value)

#If you need to add to the histogram just for graphing purposes - remember to remove!
#new_row <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 2)
#new_row2 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 4)
#new_row3 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 5)

#subset_data <- rbind(new_row, new_row2, subset_data)

noncont_arm_loss_histo <- ggplot(subset_data, aes(x = bin, fill = bin)) + geom_bar(position = "dodge", stat = "count", fill = "deepskyblue4") + labs(title = paste("Histogram of total_values_summed for", chr_arm_value), x = "Total Values Summed", y = "Frequency") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 

noncont_arm_loss_histo

#By chromosome, frequency of each arm loss
chr_value <- "22"
subset_data <- subset(noncont_loss_samples, Chr == chr_value)

arm_counts <- data.frame(arm = c("p_only", "q_only", "pq_both"), counts = numeric(3))  # Initialize with zeros
sum_p_only <- sum(subset_data$p_only)
sum_q_only <- sum(subset_data$q_only)
sum_pq_both <- sum(subset_data$pq_both)

arm_counts$counts[arm_counts$arm == "p_only"] <- sum_p_only
arm_counts$counts[arm_counts$arm == "q_only"] <- sum_q_only
arm_counts$counts[arm_counts$arm == "pq_both"] <- sum_pq_both

arm_order <- c("p_only", "q_only", "pq_both")
arm_counts$arm <- factor(arm_counts$arm, levels = arm_order)

# Create the bar graph
noncont_loss_freq <- ggplot(arm_counts, aes(x = arm, y = counts)) +
  geom_bar(stat = "identity", fill = "deepskyblue4") +
  labs(title = "Frequency Plot of Arm Types",
       x = "Arm Types", y = "Counts") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 

noncont_loss_freq

# Create the horizontal stacked bar plot
arm_colors <- c("p_only" = "lightcyan3", "q_only" = "seagreen3", "pq_both" = "goldenrod3")

noncont_loss_freq_v2 <- ggplot(arm_counts, aes(x = factor(1), y = counts, fill = arm)) +
  geom_bar(stat = "identity", position = "stack", color = "grey") +
  scale_fill_manual(values = arm_colors) +
  labs(title = "Stacked Bar Plot of Arm Types",
       x = "Counts", y = "") +  # Adjust the axis labels as needed
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(),
        axis.text = element_text(size = 18)) +
  scale_x_discrete(labels = NULL)  # Hide x-axis labels since we only have one category

#By arm, number of fragments gained
noncont_arm_gain_samples_histo <- noncont_arm_gain_samples %>%  mutate(bin = cut(total_values_summed, breaks = c(0, 1, 2, 3, 4, Inf), labels = c("1", "2", "3", "4", "5+")))

chr_arm_value <- "22q"
subset_data <- subset(noncont_arm_gain_samples_histo, Chr_Arm == chr_arm_value)

#If you need to add to the histogram just for graphing purposes - remember to remove!
#new_row <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 4)
#new_row2 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 4)
#new_row3 <- data.frame(Sample = 0, Chr = 0, Arm_checked = 0, Event = 0, total_arm_pct = 0, total_values_summed = 0, total_arm_bp = 0, size_mb = 0, Chr_Arm = "5p", bin = 5)

#subset_data <- rbind(new_row, subset_data)

noncont_arm_gain_histo <- ggplot(subset_data, aes(x = bin, fill = bin)) + geom_bar(position = "dodge", stat = "count", fill = "firebrick4") + labs(title = paste("Histogram of total_values_summed for", chr_arm_value), x = "Total Values Summed", y = "Frequency") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 

noncont_arm_gain_histo

#By chromosome, frequency of each arm gain
chr_value <- "21"
subset_data <- subset(noncont_gain_samples, Chr == chr_value)

arm_counts <- data.frame(arm = c("p_only", "q_only", "pq_both"), counts = numeric(3))  # Initialize with zeros
sum_p_only <- sum(subset_data$p_only)
sum_q_only <- sum(subset_data$q_only)
sum_pq_both <- sum(subset_data$pq_both)

arm_counts$counts[arm_counts$arm == "p_only"] <- sum_p_only
arm_counts$counts[arm_counts$arm == "q_only"] <- sum_q_only
arm_counts$counts[arm_counts$arm == "pq_both"] <- sum_pq_both

arm_order <- c("p_only", "q_only", "pq_both")
arm_counts$arm <- factor(arm_counts$arm, levels = arm_order)

# Create the bar graph
noncont_gain_freq <- ggplot(arm_counts, aes(x = arm, y = counts)) +
  geom_bar(stat = "identity", fill = "firebrick4") +
  labs(title = "Frequency Plot of Arm Types",
       x = "Arm Types", y = "Counts") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 

noncont_gain_freq

# Create the horizontal stacked bar plot
arm_colors <- c("p_only" = "lightcyan3", "q_only" = "seagreen3", "pq_both" = "goldenrod3")

noncont_gain_freq_v2 <- ggplot(arm_counts, aes(x = factor(1), y = counts, fill = arm)) +
  geom_bar(stat = "identity", position = "stack", color = "grey") +
  scale_fill_manual(values = arm_colors) +
  labs(title = "Stacked Bar Plot of Arm Types",
       x = "Counts", y = "") +  # Adjust the axis labels as needed
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_blank(),
        axis.text = element_text(size = 18)) +
  scale_x_discrete(labels = NULL)  # Hide x-axis labels since we only have one category

```

```{r}
#Now start looking at how # of calls change based on threshold - going to do this for all chromosomes, two sets of 20
chr_list_1 <- c('1p', '1q', '2p', '2q', '3p', '3q', '4p', '4q', '5p', '5q', '6p', '6q', '7p', '7q', '8p', '8q', '9p', '9q', '10p', '10q')
chr_list_2 <- c('11p', '11q', '12p', '12q', '13q', '14q', '15q', '16p', '16q', '17p', '17q', '18p', '18q', '19p', '19q', '20p', '20q', '21p', '21q', '22q')

threshold_values <- data.frame(threshold = 0:100)
plot_threshold <- threshold_values

# Loop through each variable in chr_list_1, then replace variables to do it for chr_list_2
for (chr_var in chr_list_1) {
  #Subset to particular chr arm
  subset_data <- subset(noncont_arm_loss_samples_histo, Chr_Arm == chr_var) #Edit this if you want to switch over to looking at gain calls
  # Calculate counts for each threshold and variable
  counts <- threshold_values %>%
    mutate(Count = sapply(threshold, function(thresh) {
      sum(subset_data$total_arm_pct >= thresh)
    }))
  
  # Rename the Count column to the current variable in chr_list
  colnames(counts)[colnames(counts) == "Count"] <- chr_var
  
  # Merge the counts with the existing plot_threshold data frame
  plot_threshold <- merge(plot_threshold, counts, by = "threshold", all = TRUE)
}

# Calculate maximum values for each column
max_values <- plot_threshold %>%
  select(-threshold) %>%
  summarise(across(everything(), max, na.rm = TRUE))

# Convert counts to percentages based on maximum values
plot_threshold_percent <- plot_threshold %>% mutate(across(-threshold, ~ . / max_values[[cur_column()]]))

# Reshape the data for plotting - change the color and need to update references above if want to plot gains
plot_data_long <- plot_threshold_percent %>% pivot_longer(cols = -threshold, names_to = "Chr_Arm", values_to = "Value")

plot_list <- lapply(chr_list_1, function(chr_arm) {
  ggplot(data = plot_data_long %>% filter(Chr_Arm == chr_arm),
         aes(x = threshold, y = Value)) +
    geom_line(color="deepskyblue4", size = 1.25) + #firebrick4 for gain plots, deepskyblue4 for loss plots
    labs(x = NULL, y = chr_arm) +
    scale_x_continuous(breaks = seq(0, 100, by = 10)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey", linewidth = 0.3), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank())
})
#See below to execute the plot

```
# Combine the line plots vertically
combined_plots <- do.call(grid.arrange, c(plot_list, ncol = 1))
print(combined_plots)

```{r}
#Create derivative plots to understand at what thresholds are calls changing the most rapidly
# Function to calculate the derivative of the arm loss call plots. Adjust previous code chunk to switch the sheet between gains and losses and the chr_list
calculate_derivative <- function(data) {
  data %>%
    mutate(derivative = c(NA, abs(diff(Value) / diff(threshold))))
}

# Function to create individual plots with derivatives
create_plot_with_derivative <- function(chr_arm) {
  plot_data_filtered <- plot_data_long %>%
    filter(Chr_Arm == chr_arm)
  
  plot_data_with_derivative <- calculate_derivative(plot_data_filtered)
  
  ggplot(data = plot_data_with_derivative,
         aes(x = threshold, y = derivative)) +
    geom_line(color = "chartreuse4", size = 0.50) +
    labs(x = NULL, y = chr_arm) +
    scale_x_continuous(breaks = seq(0, 100, by = 10)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey", linewidth = 0.3), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank())
}

# Create a list of individual plots with derivatives
plot_list <- lapply(chr_list_1, create_plot_with_derivative)
```

# Combine plots into a single column
combined_plots <- cowplot::plot_grid(plotlist = plot_list, ncol = 1)

# Print the combined plot
print(combined_plots)


```{r}
#Perform AUC calculations for above line plots

chr_arm = '19q'
subset_data <- subset(plot_threshold_percent, select = c("threshold", chr_arm))
subset_data_5 <- subset(subset_data, threshold >= 5 & threshold <= 50)
colnames(subset_data_5)[2] <- "Arm"
subset_data_95 <- subset(subset_data, threshold >= 50 & threshold <= 95)
colnames(subset_data_95)[2] <- "Arm"

area_under_curve_5 <- sum(diff(subset_data_5$threshold) * (subset_data_5$Arm[-1] + subset_data_5$Arm[-length(subset_data_5$Arm)]) / 2)
print(area_under_curve_5)

area_under_curve_95 <- sum(diff(subset_data_95$threshold) * (subset_data_95$Arm[-1] + subset_data_95$Arm[-length(subset_data_95$Arm)]) / 2)
print(area_under_curve_95)

```

```{r}
#Calculating Integrated Grade for samples that we have mitoses and CDKN2A information
#Clinical information and barcodes cannot be publicly released, please contact corresponding author of the manuscript for additional information on clinical data.

#Import master meningioma sheet
master_file_name <- "meningioma_clinical_master_RPreview.xlsx"
master_file_path <- file.path(path, master_file_name)
mening_master <- read.xlsx(master_file_path)

#Import array barcodes (some of our data only has barcodes no CG number)
barcode_file_name <- "array_barcodes.xlsx"
barcode_file_path <- file.path(path, barcode_file_name)
barcode <- read.xlsx(barcode_file_path)
```

```{r}
#Calculating Integrated Grade for samples that we have mitoses and CDKN2A information

#Create template integrated grade dataframe
integrated_grade <- data.frame(Sample = unique(noncont_mening_seg_arm_unique$Sample))

# Extract part from "CG" onward for each row
integrated_grade <- integrated_grade %>% mutate(sample_short = str_sub(Sample, start = str_locate(Sample, "CG")[, "start"]))

integrated_grade <- integrated_grade %>% mutate(barcode_extract = str_extract(Sample, "(?<=US83003520_)\\d+"))
integrated_grade <- merge(integrated_grade, barcode, by.x = "barcode_extract", by.y = "barcode", all.x = TRUE)
integrated_grade <- integrated_grade %>% mutate(sample_short = ifelse(!is.na(barcode_extract), cg_val, sample_short))
integrated_grade <- integrated_grade %>% select(-c(barcode_extract, cg_val))

# Remove duplicates from mening_master based on CG_merged
unique_mening_master <- mening_master %>% distinct(CG_merged, .keep_all = TRUE)

#Merge mitoses, CDKN2A/B, recurrence data. Convert CDKN2A to binary. Bin mitoses by integrated grade
integrated_grade <- integrated_grade %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, mitoses, CDKN2A, recur), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade %>% filter(is.na(sample_short)))

integrated_grade$CDKN2A <- ifelse(integrated_grade$CDKN2A %in% c("SCL", "TCL", "SCL/TCL", "POLY"), 1, integrated_grade$CDKN2A)
integrated_grade$CDKN2A <- ifelse(integrated_grade$CDKN2A %in% c("SCG", "SCG/POLY", "SCG/TRI"), 0, integrated_grade$CDKN2A)
integrated_grade$CDKN2A <- as.numeric(integrated_grade$CDKN2A)

integrated_grade$recur <- as.numeric(integrated_grade$recur)
integrated_grade$mitoses <- as.numeric(integrated_grade$mitoses)

integrated_grade <- integrated_grade %>% mutate(mitoses_binned = ifelse(is.na(mitoses), NA_integer_, ifelse(mitoses < 4, 0, ifelse(mitoses >= 4 & mitoses <= 19, 1, 2))))

#Save a version of integrated_grade for HR calculations in next chunk
integrated_grade_hr <- integrated_grade

#Prep additional data needed (adding 22q here for validation of Patel classifier, not needed for IG or integrated score) - this will change the subsetting criteria in the script below to 22q not 19q
integrated_grade[, c("1p", "3p", "4p", "4q", "6p", "6q", "10p", "10q", "14q", "18p", "18q", "19p", "19q", "22q")] <- 0
noncont_arm_loss_samples$Chr_Arm <- as.character(noncont_arm_loss_samples$Chr_Arm)

#Calls at threshold = 5%
integrated_grade_5 <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_5 that matches the sample name
  row_index <- which(integrated_grade_5$Sample == sample_name)
  
  # If total_arm_pct is greater than or equal to 5, update the corresponding column
  if (!is.na(row_index) && total_arm_pct >= 5) {
    integrated_grade_5[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_22q <- which(colnames(integrated_grade_5) == "22q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_5 <- integrated_grade_5[, 1:index_22q]


#Calls at threshold = 25%
integrated_grade_25 <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_25 that matches the sample name
  row_index <- which(integrated_grade_25$Sample == sample_name)
  
  # If total_arm_pct is greater than or equal to 25, update the corresponding column
  if (!is.na(row_index) && total_arm_pct >= 25) {
    integrated_grade_25[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_22q <- which(colnames(integrated_grade_25) == "22q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_25 <- integrated_grade_25[, 1:index_22q]


#Calls at threshold = 50%
integrated_grade_50 <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_50 that matches the sample name
  row_index <- which(integrated_grade_50$Sample == sample_name)
  
  # If total_arm_pct is greater than or equal to 50, update the corresponding column
  if (!is.na(row_index) && total_arm_pct >= 50) {
    integrated_grade_50[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_22q <- which(colnames(integrated_grade_50) == "22q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_50 <- integrated_grade_50[, 1:index_22q]



#Calls at threshold = 75%
integrated_grade_75 <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_75 that matches the sample name
  row_index <- which(integrated_grade_75$Sample == sample_name)
  
  # If total_arm_pct is greater than or equal to 75, update the corresponding column
  if (!is.na(row_index) && total_arm_pct >= 75) {
    integrated_grade_75[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_22q <- which(colnames(integrated_grade_75) == "22q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_75 <- integrated_grade_75[, 1:index_22q]



#Calls at threshold = 95%
integrated_grade_95 <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_95 that matches the sample name
  row_index <- which(integrated_grade_95$Sample == sample_name)
  
  # If total_arm_pct is greater than or equal to 95, update the corresponding column
  if (!is.na(row_index) && total_arm_pct >= 95) {
    integrated_grade_95[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_22q <- which(colnames(integrated_grade_95) == "22q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_95 <- integrated_grade_95[, 1:index_22q]


#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data

integrated_grade_5 <- integrated_grade_5 %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_25 <- integrated_grade_25 %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_50 <- integrated_grade_50 %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_75 <- integrated_grade_75 %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_95 <- integrated_grade_95 %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))

#Combine the Integrated Grade arm calls

integrated_grade_5 <- integrated_grade_5 %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_5 <- integrated_grade_5 %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_5 <- integrated_grade_5 %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_5 <- integrated_grade_5 %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_5 <- integrated_grade_5 %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_25 <- integrated_grade_25 %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_25 <- integrated_grade_25 %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_25 <- integrated_grade_25 %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_25 <- integrated_grade_25 %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_25 <- integrated_grade_25 %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_50 <- integrated_grade_50 %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_50 <- integrated_grade_50 %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_50 <- integrated_grade_50 %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_50 <- integrated_grade_50 %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_50 <- integrated_grade_50 %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_75 <- integrated_grade_75 %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_75 <- integrated_grade_75 %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_75 <- integrated_grade_75 %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_75 <- integrated_grade_75 %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_75 <- integrated_grade_75 %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_95 <- integrated_grade_95 %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_95 <- integrated_grade_95 %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_95 <- integrated_grade_95 %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_95 <- integrated_grade_95 %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_95 <- integrated_grade_95 %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

#Calculate Integrated Grade
integrated_grade_5 <- integrated_grade_5 %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_5 <- integrated_grade_5 %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_25 <- integrated_grade_25 %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_25 <- integrated_grade_25 %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_50 <- integrated_grade_50 %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_50 <- integrated_grade_50 %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_75 <- integrated_grade_75 %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_75 <- integrated_grade_75 %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_95 <- integrated_grade_95 %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_95 <- integrated_grade_95 %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))


#Remove duplicate samples
integrated_grade_5 <- integrated_grade_5 %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_25 <- integrated_grade_25 %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_50 <- integrated_grade_50 %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_75 <- integrated_grade_75 %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_95 <- integrated_grade_95 %>% distinct(sample_short, .keep_all = TRUE)

ig_counts_5 <- table(integrated_grade_5$ig)
ig_counts_25 <- table(integrated_grade_25$ig)
ig_counts_50 <- table(integrated_grade_50$ig)
ig_counts_75 <- table(integrated_grade_75$ig)
ig_counts_95 <- table(integrated_grade_95$ig)

```


```{r}
#Analysis of how IG changed

ig_analysis <- integrated_grade_5 %>% select(sample_short, ig) %>% rename(ig_5 = ig)

ig_analysis <- merge(ig_analysis, integrated_grade_25[, c("sample_short", "ig")], by = "sample_short", all.x = TRUE)
colnames(ig_analysis)[ncol(ig_analysis)] <- "ig_25"

ig_analysis <- merge(ig_analysis, integrated_grade_50[, c("sample_short", "ig")], by = "sample_short", all.x = TRUE)
colnames(ig_analysis)[ncol(ig_analysis)] <- "ig_50"

ig_analysis <- merge(ig_analysis, integrated_grade_75[, c("sample_short", "ig")], by = "sample_short", all.x = TRUE)
colnames(ig_analysis)[ncol(ig_analysis)] <- "ig_75"

ig_analysis <- merge(ig_analysis, integrated_grade_95[, c("sample_short", "ig")], by = "sample_short", all.x = TRUE)
colnames(ig_analysis)[ncol(ig_analysis)] <- "ig_95"

combination_5_25 <- table(ig_analysis$ig_5, ig_analysis$ig_25)
combination_25_50 <- table(ig_analysis$ig_25, ig_analysis$ig_50)
combination_50_75 <- table(ig_analysis$ig_50, ig_analysis$ig_75)
combination_75_95 <- table(ig_analysis$ig_75, ig_analysis$ig_95)

# Plot heatmap to show which arms contributed to IG change across the thresholds

#Import master meningioma sheet
heatmap_file_name <- "threshold_armchange_heatmap_V2.xlsx"
heatmap_file_path <- file.path(path, heatmap_file_name)
heatmap_ig <- read.xlsx(heatmap_file_path)

thresh_ordered <- c("five", "twentyfive", "fifty", "seventyfive", "ninetyfive")
arm_ordered <- c("1p", "3p", "4p", "4q", "6p", "6q", "10p", "10q", "14q", "18p", "18q", "19p", "19q")

heatmap_arm_change <- ggplot(heatmap_ig, aes(x = factor(thresh), y = factor(arm), fill = val_norm)) +
  geom_tile() +
  scale_fill_gradient(low = "deepskyblue3", high = "orange1") +  # Specify the color scale
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.text = element_text(size=18)) +
  scale_x_discrete(limits = thresh_ordered) +  # Specify the order of x-axis variables
  scale_y_discrete(limits = rev(arm_ordered))  # Specify the order of y-axis variables

heatmap_raw_arm_change <- ggplot(heatmap_ig, aes(x = factor(thresh), y = factor(arm), fill = val)) +
  geom_tile() +
  scale_fill_gradient(low = "deepskyblue3", high = "darkgoldenrod1") +  # Specify the color scale
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.text = element_text(size=18)) +
  scale_x_discrete(limits = thresh_ordered) +  # Specify the order of x-axis variables
  scale_y_discrete(limits = rev(arm_ordered))  # Specify the order of y-axis variables
```


```{r}
# This code chunk ties us back to the question of absolute amount of chromsome lost. Here, we're going to calculate the integrated grade using the absolute size at different size thresholds to see how that impacts prognostication
# This relies on running the previous code chunk which calculated the different integrated grade values at different threshold percentages

#Calls at threshold = 3 Mb
integrated_grade_3abs <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  size_mb <- noncont_arm_loss_samples$size_mb[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_3abs that matches the sample name
  row_index <- which(integrated_grade_3abs$Sample == sample_name)
  
  # If size_mb is greater than or equal to 3 Mb, update the corresponding column
  if (!is.na(row_index) && size_mb >= 3) {
    integrated_grade_3abs[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_19q <- which(colnames(integrated_grade_3abs) == "19q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_3abs <- integrated_grade_3abs[, 1:index_19q]


#Calls at threshold = 6 Mb
integrated_grade_6abs <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  size_mb <- noncont_arm_loss_samples$size_mb[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_6abs that matches the sample name
  row_index <- which(integrated_grade_6abs$Sample == sample_name)
  
  # If size_mb is greater than or equal to 6 Mb, update the corresponding column
  if (!is.na(row_index) && size_mb >= 6) {
    integrated_grade_6abs[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_19q <- which(colnames(integrated_grade_6abs) == "19q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_6abs <- integrated_grade_6abs[, 1:index_19q]


#Calls at threshold = 9 Mb
integrated_grade_9abs <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  size_mb <- noncont_arm_loss_samples$size_mb[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_9abs that matches the sample name
  row_index <- which(integrated_grade_9abs$Sample == sample_name)
  
  # If size_mb is greater than or equal to 9 Mb, update the corresponding column
  if (!is.na(row_index) && size_mb >= 9) {
    integrated_grade_9abs[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_19q <- which(colnames(integrated_grade_9abs) == "19q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_9abs <- integrated_grade_9abs[, 1:index_19q]


#Calls at threshold = 12 Mb
integrated_grade_12abs <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  size_mb <- noncont_arm_loss_samples$size_mb[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_12abs that matches the sample name
  row_index <- which(integrated_grade_12abs$Sample == sample_name)
  
  # If size_mb is greater than or equal to 12 Mb, update the corresponding column
  if (!is.na(row_index) && size_mb >= 12) {
    integrated_grade_12abs[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_19q <- which(colnames(integrated_grade_12abs) == "19q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_12abs <- integrated_grade_12abs[, 1:index_19q]


#Calls at threshold = 15 Mb
integrated_grade_15abs <- integrated_grade

for (i in 1:nrow(noncont_arm_loss_samples)) {
  sample_name <- noncont_arm_loss_samples$Sample[i]
  size_mb <- noncont_arm_loss_samples$size_mb[i]
  chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
  
  # Find the row in integrated_grade_15abs that matches the sample name
  row_index <- which(integrated_grade_15abs$Sample == sample_name)
  
  # If size_mb is greater than or equal to 15 Mb, update the corresponding column
  if (!is.na(row_index) && size_mb >= 15) {
    integrated_grade_15abs[row_index, chr_arm] <- 1
  }
}
# Get the index of the "19q" column
index_19q <- which(colnames(integrated_grade_15abs) == "19q")

# Subset the dataframe to keep columns up to "19q"
integrated_grade_15abs <- integrated_grade_15abs[, 1:index_19q]


#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data

integrated_grade_3abs <- integrated_grade_3abs %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_6abs <- integrated_grade_6abs %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_9abs <- integrated_grade_9abs %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_12abs <- integrated_grade_12abs %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_15abs <- integrated_grade_15abs %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))

#Combine the Integrated Grade arm calls

integrated_grade_3abs <- integrated_grade_3abs %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_6abs <- integrated_grade_6abs %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_6abs <- integrated_grade_6abs %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_6abs <- integrated_grade_6abs %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_6abs <- integrated_grade_6abs %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_6abs <- integrated_grade_6abs %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_9abs <- integrated_grade_9abs %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_9abs <- integrated_grade_9abs %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_9abs <- integrated_grade_9abs %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_9abs <- integrated_grade_9abs %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_9abs <- integrated_grade_9abs %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_12abs <- integrated_grade_12abs %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_12abs <- integrated_grade_12abs %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_12abs <- integrated_grade_12abs %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_12abs <- integrated_grade_12abs %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_12abs <- integrated_grade_12abs %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

integrated_grade_15abs <- integrated_grade_15abs %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_15abs <- integrated_grade_15abs %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_15abs <- integrated_grade_15abs %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_15abs <- integrated_grade_15abs %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_15abs <- integrated_grade_15abs %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

#Calculate Integrated Grade
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_3abs <- integrated_grade_3abs %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_6abs <- integrated_grade_6abs %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_6abs <- integrated_grade_6abs %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_9abs <- integrated_grade_9abs %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_9abs <- integrated_grade_9abs %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_12abs <- integrated_grade_12abs %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_12abs <- integrated_grade_12abs %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

integrated_grade_15abs <- integrated_grade_15abs %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_15abs <- integrated_grade_15abs %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))


#Remove duplicate samples
integrated_grade_3abs <- integrated_grade_3abs %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_6abs <- integrated_grade_6abs %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_9abs <- integrated_grade_9abs %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_12abs <- integrated_grade_12abs %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_15abs <- integrated_grade_15abs %>% distinct(sample_short, .keep_all = TRUE)

ig_counts_3abs <- table(integrated_grade_3abs$ig)
ig_counts_6abs <- table(integrated_grade_6abs$ig)
ig_counts_9abs <- table(integrated_grade_9abs$ig)
ig_counts_12abs <- table(integrated_grade_12abs$ig)
ig_counts_15abs <- table(integrated_grade_15abs$ig)


```

```{r}
#Merge in follow-up data to only run HR plots on patients who had 6 mo of follow-up (check months_lastfu column). Merge in verified recurrence data
#Clinical information cannot be released publicly, please contact the corresponding author for data related to clinical outcomes.

integrated_grade_hr <- integrated_grade_hr %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr %>% filter(is.na(sample_short)))

integrated_grade_hr <- integrated_grade_hr %>% filter(months_lastfu >= 6)

```


```{r}
#This is the beginning of a long chunk of code where we do integrate grade calculations and HR plots across thresholds. A code chunk will be created for each chromosome. You need to edit the arm name (e.g., 1p, 1q), the sheet being used (noncont_arm_loss_samples or noncont_arm_gain_samples), and the color of the plot in order to create the plot that you want
#Arm 1q loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_1p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("1p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_1p[new_column_names] <- 0

for (sample in integrated_grade_hr_1p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "1p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "1p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("1p_", threshold)
        integrated_grade_hr_1p[integrated_grade_hr_1p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("1p_", threshold)
        integrated_grade_hr_1p[integrated_grade_hr_1p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_1p <- integrated_grade_hr_1p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_1p <- integrated_grade_hr_1p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_1p <- integrated_grade_hr_1p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_1p %>% filter(is.na(sample_short)))

integrated_grade_hr_1p$primary.y <- as.numeric(integrated_grade_hr_1p$primary.y)
integrated_grade_hr_1p$priorRT <- as.numeric(integrated_grade_hr_1p$priorRT)
integrated_grade_hr_1p$GTR <- as.numeric(integrated_grade_hr_1p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_1p_test <- integrated_grade_hr_1p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 1p threshold with recurrence column
or_1p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("1p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_1p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_1p_results <- rbind(or_1p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_1p_results <- or_1p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_1p_results <- or_1p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 1p
or_1p_results <- or_1p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_1p_loss_plot <- ggplot(or_1p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) + #deepskyblue4 or firebrick4
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) + #deepskyblue1 or firebrick1
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 2 HR calculations: primary, non-radiated, GTR

integrated_grade_hr_2q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("2q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_2q[new_column_names] <- 0

for (sample in integrated_grade_hr_2q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "2q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "2q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("2q_", threshold)
        integrated_grade_hr_2q[integrated_grade_hr_2q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("2q_", threshold)
        integrated_grade_hr_2q[integrated_grade_hr_2q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_2q <- integrated_grade_hr_2q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_2q <- integrated_grade_hr_2q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_2q <- integrated_grade_hr_2q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_2q %>% filter(is.na(sample_short)))

integrated_grade_hr_2q$primary.y <- as.numeric(integrated_grade_hr_2q$primary.y)
integrated_grade_hr_2q$priorRT <- as.numeric(integrated_grade_hr_2q$priorRT)
integrated_grade_hr_2q$GTR <- as.numeric(integrated_grade_hr_2q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_2q_test <- integrated_grade_hr_2q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 2q threshold with recurrence column
or_2q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("2q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_2q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_2q_results <- rbind(or_2q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_2q_results <- or_2q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_2q_results <- or_2q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)


#Resolving undefined CIs for 2q
or_2q_results <- or_2q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_2q_loss_plot <- ggplot(or_2q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```


```{r}
#Chromosome 3 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_3q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("3q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_3q[new_column_names] <- 0

for (sample in integrated_grade_hr_3q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "3q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "3q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("3q_", threshold)
        integrated_grade_hr_3q[integrated_grade_hr_3q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("3q_", threshold)
        integrated_grade_hr_3q[integrated_grade_hr_3q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_3q <- integrated_grade_hr_3q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_3q <- integrated_grade_hr_3q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_3q <- integrated_grade_hr_3q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_3q %>% filter(is.na(sample_short)))

integrated_grade_hr_3q$primary.y <- as.numeric(integrated_grade_hr_3q$primary.y)
integrated_grade_hr_3q$priorRT <- as.numeric(integrated_grade_hr_3q$priorRT)
integrated_grade_hr_3q$GTR <- as.numeric(integrated_grade_hr_3q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_3q_test <- integrated_grade_hr_3q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 3q threshold with recurrence column
or_3q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("3q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_3q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_3q_results <- rbind(or_3q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_3q_results <- or_3q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_3q_results <- or_3q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 3q
or_3q_results <- or_3q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_3q_loss_plot <- ggplot(or_3q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 4 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_4q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("4q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_4q[new_column_names] <- 0

for (sample in integrated_grade_hr_4q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "4q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "4q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("4q_", threshold)
        integrated_grade_hr_4q[integrated_grade_hr_4q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("4q_", threshold)
        integrated_grade_hr_4q[integrated_grade_hr_4q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_4q <- integrated_grade_hr_4q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_4q <- integrated_grade_hr_4q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_4q <- integrated_grade_hr_4q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_4q %>% filter(is.na(sample_short)))

integrated_grade_hr_4q$primary.y <- as.numeric(integrated_grade_hr_4q$primary.y)
integrated_grade_hr_4q$priorRT <- as.numeric(integrated_grade_hr_4q$priorRT)
integrated_grade_hr_4q$GTR <- as.numeric(integrated_grade_hr_4q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_4q_test <- integrated_grade_hr_4q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 4q threshold with recurrence column
or_4q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("4q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_4q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_4q_results <- rbind(or_4q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_4q_results <- or_4q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_4q_results <- or_4q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 4q
or_4q_results <- or_4q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_4q_loss_plot <- ggplot(or_4q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 5 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_5p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("5p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_5p[new_column_names] <- 0

for (sample in integrated_grade_hr_5p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "5p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "5p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("5p_", threshold)
        integrated_grade_hr_5p[integrated_grade_hr_5p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("5p_", threshold)
        integrated_grade_hr_5p[integrated_grade_hr_5p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_5p <- integrated_grade_hr_5p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_5p <- integrated_grade_hr_5p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_5p <- integrated_grade_hr_5p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_5p %>% filter(is.na(sample_short)))

integrated_grade_hr_5p$primary.y <- as.numeric(integrated_grade_hr_5p$primary.y)
integrated_grade_hr_5p$priorRT <- as.numeric(integrated_grade_hr_5p$priorRT)
integrated_grade_hr_5p$GTR <- as.numeric(integrated_grade_hr_5p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_5p_test <- integrated_grade_hr_5p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 5p threshold with recurrence column
or_5p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("5p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_5p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_5p_results <- rbind(or_5p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_5p_results <- or_5p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_5p_results <- or_5p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)


#Resolving undefined CIs for 5p
or_5p_results <- or_5p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_5p_loss_plot <- ggplot(or_5p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 6 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_6q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("6q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_6q[new_column_names] <- 0

for (sample in integrated_grade_hr_6q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "6q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "6q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("6q_", threshold)
        integrated_grade_hr_6q[integrated_grade_hr_6q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("6q_", threshold)
        integrated_grade_hr_6q[integrated_grade_hr_6q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_6q <- integrated_grade_hr_6q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_6q <- integrated_grade_hr_6q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_6q <- integrated_grade_hr_6q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_6q %>% filter(is.na(sample_short)))

integrated_grade_hr_6q$primary.y <- as.numeric(integrated_grade_hr_6q$primary.y)
integrated_grade_hr_6q$priorRT <- as.numeric(integrated_grade_hr_6q$priorRT)
integrated_grade_hr_6q$GTR <- as.numeric(integrated_grade_hr_6q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_6q_test <- integrated_grade_hr_6q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 6q threshold with recurrence column
or_6q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("6q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_6q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_6q_results <- rbind(or_6q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_6q_results <- or_6q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_6q_results <- or_6q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 6q
or_6q_results <- or_6q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_6q_loss_plot <- ggplot(or_6q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 7 HR calculations: primary, non-radiated, GTR

integrated_grade_hr_7p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("7p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_7p[new_column_names] <- 0

for (sample in integrated_grade_hr_7p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "7p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "7p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("7p_", threshold)
        integrated_grade_hr_7p[integrated_grade_hr_7p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("7p_", threshold)
        integrated_grade_hr_7p[integrated_grade_hr_7p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_7p <- integrated_grade_hr_7p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_7p <- integrated_grade_hr_7p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_7p <- integrated_grade_hr_7p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_7p %>% filter(is.na(sample_short)))

integrated_grade_hr_7p$primary.y <- as.numeric(integrated_grade_hr_7p$primary.y)
integrated_grade_hr_7p$priorRT <- as.numeric(integrated_grade_hr_7p$priorRT)
integrated_grade_hr_7p$GTR <- as.numeric(integrated_grade_hr_7p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_7p_test <- integrated_grade_hr_7p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 7p threshold with recurrence column
or_7p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("7p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_7p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_7p_results <- rbind(or_7p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_7p_results <- or_7p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_7p_results <- or_7p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 7p
or_7p_results <- or_7p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_7p_loss_plot <- ggplot(or_7p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 8 HR calculations: primary, non-radiated, GTR

integrated_grade_hr_8p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("8p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_8p[new_column_names] <- 0

for (sample in integrated_grade_hr_8p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "8p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "8p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("8p_", threshold)
        integrated_grade_hr_8p[integrated_grade_hr_8p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("8p_", threshold)
        integrated_grade_hr_8p[integrated_grade_hr_8p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_8p <- integrated_grade_hr_8p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_8p <- integrated_grade_hr_8p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_8p <- integrated_grade_hr_8p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_8p %>% filter(is.na(sample_short)))

integrated_grade_hr_8p$primary.y <- as.numeric(integrated_grade_hr_8p$primary.y)
integrated_grade_hr_8p$priorRT <- as.numeric(integrated_grade_hr_8p$priorRT)
integrated_grade_hr_8p$GTR <- as.numeric(integrated_grade_hr_8p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_8p_test <- integrated_grade_hr_8p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 8p threshold with recurrence column
or_8p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("8p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_8p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_8p_results <- rbind(or_8p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_8p_results <- or_8p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_8p_results <- or_8p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 8p
or_8p_results <- or_8p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_8p_loss_plot <- ggplot(or_8p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 9 HR calculations: primary, non-radiated, GTR

integrated_grade_hr_9q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("9q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_9q[new_column_names] <- 0

for (sample in integrated_grade_hr_9q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "9q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "9q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("9q_", threshold)
        integrated_grade_hr_9q[integrated_grade_hr_9q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("9q_", threshold)
        integrated_grade_hr_9q[integrated_grade_hr_9q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_9q <- integrated_grade_hr_9q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_9q <- integrated_grade_hr_9q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_9q <- integrated_grade_hr_9q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_9q %>% filter(is.na(sample_short)))

integrated_grade_hr_9q$primary.y <- as.numeric(integrated_grade_hr_9q$primary.y)
integrated_grade_hr_9q$priorRT <- as.numeric(integrated_grade_hr_9q$priorRT)
integrated_grade_hr_9q$GTR <- as.numeric(integrated_grade_hr_9q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_9q_test <- integrated_grade_hr_9q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 9q threshold with recurrence column
or_9q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("9q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_9q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_9q_results <- rbind(or_9q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_9q_results <- or_9q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_9q_results <- or_9q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 9q
or_9q_results <- or_9q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_9q_loss_plot <- ggplot(or_9q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```


```{r}
#Chromosome 10 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_10p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("10p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_10p[new_column_names] <- 0

for (sample in integrated_grade_hr_10p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "10p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "10p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("10p_", threshold)
        integrated_grade_hr_10p[integrated_grade_hr_10p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("10p_", threshold)
        integrated_grade_hr_10p[integrated_grade_hr_10p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_10p <- integrated_grade_hr_10p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_10p <- integrated_grade_hr_10p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_10p <- integrated_grade_hr_10p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_10p %>% filter(is.na(sample_short)))

integrated_grade_hr_10p$primary.y <- as.numeric(integrated_grade_hr_10p$primary.y)
integrated_grade_hr_10p$priorRT <- as.numeric(integrated_grade_hr_10p$priorRT)
integrated_grade_hr_10p$GTR <- as.numeric(integrated_grade_hr_10p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_10p_test <- integrated_grade_hr_10p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 10p threshold with recurrence column
or_10p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("10p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_10p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_10p_results <- rbind(or_10p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_10p_results <- or_10p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_10p_results <- or_10p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 10p
or_10p_results <- or_10p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_10p_loss_plot <- ggplot(or_10p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

#Plot first 20 HR plots on one panel
combined_hr_loss_plot_part1 <- plot_grid(or_1p_loss_plot, or_1q_loss_plot, or_2p_loss_plot, or_2q_loss_plot, or_3p_loss_plot, or_3q_loss_plot, or_4p_loss_plot, or_4q_loss_plot, or_5p_loss_plot, or_5q_loss_plot, or_6p_loss_plot, or_6q_loss_plot, or_7p_loss_plot, or_7q_loss_plot, or_8p_loss_plot, or_8q_loss_plot, or_9p_loss_plot, or_9q_loss_plot, or_10p_loss_plot, or_10q_loss_plot, ncol = 1)

#Plot first 20 HR plots on one panel
combined_hr_loss_plot_part1 <- plot_grid(or_1p_loss_plot, or_1q_loss_plot, or_2p_loss_plot, or_2q_loss_plot, or_3p_loss_plot, or_3q_loss_plot, or_4p_loss_plot, or_4q_loss_plot, or_5p_loss_plot, or_5q_loss_plot, or_6p_loss_plot, or_6q_loss_plot, or_7p_loss_plot, or_7q_loss_plot, or_8p_loss_plot, or_8q_loss_plot, or_9p_loss_plot, or_9q_loss_plot, or_10p_loss_plot, or_10q_loss_plot, ncol = 1)


```{r}
#Chromosome 11 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_11q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("11q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_11q[new_column_names] <- 0

for (sample in integrated_grade_hr_11q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "11q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "11q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("11q_", threshold)
        integrated_grade_hr_11q[integrated_grade_hr_11q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("11q_", threshold)
        integrated_grade_hr_11q[integrated_grade_hr_11q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_11q <- integrated_grade_hr_11q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_11q <- integrated_grade_hr_11q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_11q <- integrated_grade_hr_11q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_11q %>% filter(is.na(sample_short)))

integrated_grade_hr_11q$primary.y <- as.numeric(integrated_grade_hr_11q$primary.y)
integrated_grade_hr_11q$priorRT <- as.numeric(integrated_grade_hr_11q$priorRT)
integrated_grade_hr_11q$GTR <- as.numeric(integrated_grade_hr_11q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_11q_test <- integrated_grade_hr_11q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 11q threshold with recurrence column
or_11q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("11q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_11q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_11q_results <- rbind(or_11q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_11q_results <- or_11q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_11q_results <- or_11q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 11q
or_11q_results <- or_11q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_11q_loss_plot <- ggplot(or_11q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 12 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_12p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("12p_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_12p[new_column_names] <- 0

for (sample in integrated_grade_hr_12p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "12p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "12p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("12p_", threshold)
        integrated_grade_hr_12p[integrated_grade_hr_12p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("12p_", threshold)
        integrated_grade_hr_12p[integrated_grade_hr_12p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_12p <- integrated_grade_hr_12p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_12p <- integrated_grade_hr_12p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_12p <- integrated_grade_hr_12p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_12p %>% filter(is.na(sample_short)))

integrated_grade_hr_12p$primary.y <- as.numeric(integrated_grade_hr_12p$primary.y)
integrated_grade_hr_12p$priorRT <- as.numeric(integrated_grade_hr_12p$priorRT)
integrated_grade_hr_12p$GTR <- as.numeric(integrated_grade_hr_12p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_12p_test <- integrated_grade_hr_12p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 12p threshold with recurrence column
or_12p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("12p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_12p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_12p_results <- rbind(or_12p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_12p_results <- or_12p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_12p_results <- or_12p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 12p
or_12p_results <- or_12p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_12p_loss_plot <- ggplot(or_12p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 13 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_13q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("13q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_13q[new_column_names] <- 0

for (sample in integrated_grade_hr_13q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "13q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "13q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("13q_", threshold)
        integrated_grade_hr_13q[integrated_grade_hr_13q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("13q_", threshold)
        integrated_grade_hr_13q[integrated_grade_hr_13q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_13q <- integrated_grade_hr_13q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_13q <- integrated_grade_hr_13q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_13q <- integrated_grade_hr_13q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_13q %>% filter(is.na(sample_short)))

integrated_grade_hr_13q$primary.y <- as.numeric(integrated_grade_hr_13q$primary.y)
integrated_grade_hr_13q$priorRT <- as.numeric(integrated_grade_hr_13q$priorRT)
integrated_grade_hr_13q$GTR <- as.numeric(integrated_grade_hr_13q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_13q_test <- integrated_grade_hr_13q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 13q threshold with recurrence column
or_13q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("13q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_13q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_13q_results <- rbind(or_13q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_13q_results <- or_13q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_13q_results <- or_13q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 13q
or_13q_results <- or_13q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_13q_loss_plot <- ggplot(or_13q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Arm 14q loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_14q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("14q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_14q[new_column_names] <- 0

for (sample in integrated_grade_hr_14q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "14q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "14q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("14q_", threshold)
        integrated_grade_hr_14q[integrated_grade_hr_14q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("14q_", threshold)
        integrated_grade_hr_14q[integrated_grade_hr_14q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_14q <- integrated_grade_hr_14q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_14q <- integrated_grade_hr_14q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_14q <- integrated_grade_hr_14q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_14q %>% filter(is.na(sample_short)))

integrated_grade_hr_14q$primary.y <- as.numeric(integrated_grade_hr_14q$primary.y)
integrated_grade_hr_14q$priorRT <- as.numeric(integrated_grade_hr_14q$priorRT)
integrated_grade_hr_14q$GTR <- as.numeric(integrated_grade_hr_14q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_14q_test <- integrated_grade_hr_14q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 14q threshold with recurrence column
or_14q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("14q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_14q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_14q_results <- rbind(or_14q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_14q_results <- or_14q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_14q_results <- or_14q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 14q
or_14q_results <- or_14q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_14q_loss_plot <- ggplot(or_14q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Arm 15q loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_15q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("15q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_15q[new_column_names] <- 0

for (sample in integrated_grade_hr_15q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "15q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "15q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("15q_", threshold)
        integrated_grade_hr_15q[integrated_grade_hr_15q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("15q_", threshold)
        integrated_grade_hr_15q[integrated_grade_hr_15q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_15q <- integrated_grade_hr_15q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_15q <- integrated_grade_hr_15q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_15q <- integrated_grade_hr_15q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_15q %>% filter(is.na(sample_short)))

integrated_grade_hr_15q$primary.y <- as.numeric(integrated_grade_hr_15q$primary.y)
integrated_grade_hr_15q$priorRT <- as.numeric(integrated_grade_hr_15q$priorRT)
integrated_grade_hr_15q$GTR <- as.numeric(integrated_grade_hr_15q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_15q_test <- integrated_grade_hr_15q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 15q threshold with recurrence column
or_15q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("15q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_15q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_15q_results <- rbind(or_15q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_15q_results <- or_15q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_15q_results <- or_15q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)


#Resolving undefined CIs for 15q
or_15q_results <- or_15q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_15q_loss_plot <- ggplot(or_15q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 16 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_16q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("16q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_16q[new_column_names] <- 0

for (sample in integrated_grade_hr_16q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "16q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "16q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("16q_", threshold)
        integrated_grade_hr_16q[integrated_grade_hr_16q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("16q_", threshold)
        integrated_grade_hr_16q[integrated_grade_hr_16q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_16q <- integrated_grade_hr_16q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_16q <- integrated_grade_hr_16q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_16q <- integrated_grade_hr_16q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_16q %>% filter(is.na(sample_short)))

integrated_grade_hr_16q$primary.y <- as.numeric(integrated_grade_hr_16q$primary.y)
integrated_grade_hr_16q$priorRT <- as.numeric(integrated_grade_hr_16q$priorRT)
integrated_grade_hr_16q$GTR <- as.numeric(integrated_grade_hr_16q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_16q_test <- integrated_grade_hr_16q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 16q threshold with recurrence column
or_16q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("16q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_16q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_16q_results <- rbind(or_16q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_16q_results <- or_16q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_16q_results <- or_16q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 16q
or_16q_results <- or_16q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_16q_loss_plot <- ggplot(or_16q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 17 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_17q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("17q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_17q[new_column_names] <- 0

for (sample in integrated_grade_hr_17q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "17q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "17q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("17q_", threshold)
        integrated_grade_hr_17q[integrated_grade_hr_17q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("17q_", threshold)
        integrated_grade_hr_17q[integrated_grade_hr_17q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_17q <- integrated_grade_hr_17q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_17q <- integrated_grade_hr_17q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_17q <- integrated_grade_hr_17q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_17q %>% filter(is.na(sample_short)))

integrated_grade_hr_17q$primary.y <- as.numeric(integrated_grade_hr_17q$primary.y)
integrated_grade_hr_17q$priorRT <- as.numeric(integrated_grade_hr_17q$priorRT)
integrated_grade_hr_17q$GTR <- as.numeric(integrated_grade_hr_17q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_17q_test <- integrated_grade_hr_17q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 17q threshold with recurrence column
or_17q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("17q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_17q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_17q_results <- rbind(or_17q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_17q_results <- or_17q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_17q_results <- or_17q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 17q
or_17q_results <- or_17q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_17q_loss_plot <- ggplot(or_17q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromsome 18 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_18q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("18q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_18q[new_column_names] <- 0

for (sample in integrated_grade_hr_18q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "18q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "18q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("18q_", threshold)
        integrated_grade_hr_18q[integrated_grade_hr_18q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("18q_", threshold)
        integrated_grade_hr_18q[integrated_grade_hr_18q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_18q <- integrated_grade_hr_18q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_18q <- integrated_grade_hr_18q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_18q <- integrated_grade_hr_18q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_18q %>% filter(is.na(sample_short)))

integrated_grade_hr_18q$primary.y <- as.numeric(integrated_grade_hr_18q$primary.y)
integrated_grade_hr_18q$priorRT <- as.numeric(integrated_grade_hr_18q$priorRT)
integrated_grade_hr_18q$GTR <- as.numeric(integrated_grade_hr_18q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_18q_test <- integrated_grade_hr_18q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 18q threshold with recurrence column
or_18q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("18q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_18q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_18q_results <- rbind(or_18q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_18q_results <- or_18q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_18q_results <- or_18q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)


#Resolving undefined CIs for 18q
or_18q_results <- or_18q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_18q_loss_plot <- ggplot(or_18q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
# Chromosome 19 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_19p <- integrated_grade_hr

# Generate column names
new_column_names <- paste("19p_", 0:100, sep = "")
write.xlsx(or_19q_results, file = "/Users/ruchitpatel/Downloads/selected_columns.xlsx")
# Add new columns and initialize with 0
integrated_grade_hr_19p[new_column_names] <- 0

for (sample in integrated_grade_hr_19p$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "19p")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "19p" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("19p_", threshold)
        integrated_grade_hr_19p[integrated_grade_hr_19p$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("19p_", threshold)
        integrated_grade_hr_19p[integrated_grade_hr_19p$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_19p <- integrated_grade_hr_19p %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_19p <- integrated_grade_hr_19p %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_19p <- integrated_grade_hr_19p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_19p %>% filter(is.na(sample_short)))

integrated_grade_hr_19p$primary.y <- as.numeric(integrated_grade_hr_19p$primary.y)
integrated_grade_hr_19p$priorRT <- as.numeric(integrated_grade_hr_19p$priorRT)
integrated_grade_hr_19p$GTR <- as.numeric(integrated_grade_hr_19p$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_19p_test <- integrated_grade_hr_19p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 19p threshold with recurrence column
or_19p_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("19p_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_19p_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_19p_results <- rbind(or_19p_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_19p_results <- or_19p_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_19p_results <- or_19p_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 19p
or_19p_results <- or_19p_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_19p_loss_plot <- ggplot(or_19p_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
#Chromosome 20 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_20q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("20q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_20q[new_column_names] <- 0

for (sample in integrated_grade_hr_20q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "20q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "20q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("20q_", threshold)
        integrated_grade_hr_20q[integrated_grade_hr_20q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("20q_", threshold)
        integrated_grade_hr_20q[integrated_grade_hr_20q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_20q <- integrated_grade_hr_20q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_20q <- integrated_grade_hr_20q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_20q <- integrated_grade_hr_20q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_20q %>% filter(is.na(sample_short)))

integrated_grade_hr_20q$primary.y <- as.numeric(integrated_grade_hr_20q$primary.y)
integrated_grade_hr_20q$priorRT <- as.numeric(integrated_grade_hr_20q$priorRT)
integrated_grade_hr_20q$GTR <- as.numeric(integrated_grade_hr_20q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_20q_test <- integrated_grade_hr_20q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 20q threshold with recurrence column
or_20q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("20q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_20q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_20q_results <- rbind(or_20q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_20q_results <- or_20q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_20q_results <- or_20q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 20q
or_20q_results <- or_20q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_20q_loss_plot <- ggplot(or_20q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
# Chromosome 21 loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_21q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("21q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_21q[new_column_names] <- 0

for (sample in integrated_grade_hr_21q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "21q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "21q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("21q_", threshold)
        integrated_grade_hr_21q[integrated_grade_hr_21q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("21q_", threshold)
        integrated_grade_hr_21q[integrated_grade_hr_21q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_21q <- integrated_grade_hr_21q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_21q <- integrated_grade_hr_21q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_21q <- integrated_grade_hr_21q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_21q %>% filter(is.na(sample_short)))

integrated_grade_hr_21q$primary.y <- as.numeric(integrated_grade_hr_21q$primary.y)
integrated_grade_hr_21q$priorRT <- as.numeric(integrated_grade_hr_21q$priorRT)
integrated_grade_hr_21q$GTR <- as.numeric(integrated_grade_hr_21q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_21q_test <- integrated_grade_hr_21q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 21q threshold with recurrence column
or_21q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("21q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_21q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_21q_results <- rbind(or_21q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_21q_results <- or_21q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_21q_results <- or_21q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 21q
or_21q_results <- or_21q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_21q_loss_plot <- ggplot(or_21q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

```{r}
# Chromosome 22q loss HR calculations: primary, non-radiated, GTR

integrated_grade_hr_22q <- integrated_grade_hr

# Generate column names
new_column_names <- paste("22q_", 0:100, sep = "")

# Add new columns and initialize with 0
integrated_grade_hr_22q[new_column_names] <- 0

for (sample in integrated_grade_hr_22q$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "22q")) {
    thresholds <- 0:100
    
    for (threshold in thresholds) {
      if (any(sample_rows$Chr_Arm == "22q" & sample_rows$total_arm_pct >= threshold)) {
        col_name <- paste0("22q_", threshold)
        integrated_grade_hr_22q[integrated_grade_hr_22q$Sample == sample, col_name] <- 1
      } else {
        col_name <- paste0("22q_", threshold)
        integrated_grade_hr_22q[integrated_grade_hr_22q$Sample == sample, col_name] <- 0
      }
    }
  } else {
    # Move on to the next sample
    next
  }
}

#Clean up data: remove rows where there is no mitoses, CDKN2A, or recurrence data
integrated_grade_hr_22q <- integrated_grade_hr_22q %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_hr_22q <- integrated_grade_hr_22q %>% distinct(sample_short, .keep_all = TRUE)

#Merge in information on primary, prior RT, GTR
integrated_grade_hr_22q <- integrated_grade_hr_22q %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_hr_22q %>% filter(is.na(sample_short)))

integrated_grade_hr_22q$primary.y <- as.numeric(integrated_grade_hr_22q$primary.y)
integrated_grade_hr_22q$priorRT <- as.numeric(integrated_grade_hr_22q$priorRT)
integrated_grade_hr_22q$GTR <- as.numeric(integrated_grade_hr_22q$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_hr_22q_test <- integrated_grade_hr_22q %>% filter(primary.y == 1, priorRT == 0, GTR == 1)

#Run HR test across each 22q threshold with recurrence column
or_22q_results <- data.frame(Column = character(0), OddsRatio = numeric(0), LowerCI = numeric(0), UpperCI = numeric(0))
columns_to_test <- paste0("22q_", 0:100)

# Iterate through the columns and perform the tests
for (col_name in columns_to_test) {
  # Creating a logistic regression model
  logistic_model <- glm(recur_RP ~ . - recur_RP, data = ig_hr_22q_test %>% select(recur_RP, all_of(col_name)), family = "binomial")
  
  # Extracting odds ratio and confidence intervals
  odds_ratio_result <- tidy(logistic_model, exponentiate = TRUE)
  
  # Filter the result to get the odds ratio for the specific column
  odds_ratio_for_column <- odds_ratio_result %>% filter(term == paste0("`", col_name, "`"))
  
   # Calculate confidence intervals manually
  se <- odds_ratio_for_column$std.error
  t_value <- qt(0.975, df = logistic_model$df.residual)
  lower_ci <- odds_ratio_for_column$estimate - t_value * se
  upper_ci <- odds_ratio_for_column$estimate + t_value * se
  
  # Adding the results to the dataframe
  or_22q_results <- rbind(or_22q_results, data.frame(Column = col_name, OddsRatio = odds_ratio_for_column$estimate, 
                                                             LowerCI = lower_ci, UpperCI = upper_ci))
}

or_22q_results <- or_22q_results %>% mutate_all(~ ifelse(is.na(.), 0, .))
or_22q_results <- or_22q_results %>% separate(Column, into = c("prefix", "threshold"), sep = "_", convert = TRUE) %>% mutate(threshold = as.numeric(threshold)) %>% select(-prefix)

#Resolving undefined CIs for 22q
or_22q_results <- or_22q_results %>% mutate_all(~ ifelse(. > 1000 | . < -1000, 0, .))

#Plot the odds ratios

or_22q_loss_plot <- ggplot(or_22q_results, aes(x = threshold, y = OddsRatio)) +
  geom_line(color = "deepskyblue4", size = 1.25) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), fill = "deepskyblue1", alpha = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgray", size = 1) +
  labs(x = "Threshold", y = "Odds Ratio") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text = element_text(size=18), axis.text.x = element_blank(), axis.text.y = element_blank()) + scale_x_continuous(breaks = seq(0, 100, by = 10))

```

#Plot second 20 HR plots on one panel
combined_hr_gain_plot_part2 <- plot_grid(or_11p_gain_plot, or_11q_gain_plot, or_12p_gain_plot, or_12q_gain_plot, or_13q_gain_plot, or_14q_gain_plot, or_15q_gain_plot, or_16p_gain_plot, or_16q_gain_plot, or_17p_gain_plot, or_17q_gain_plot, or_18p_gain_plot, or_18q_gain_plot, or_19p_gain_plot, or_19q_gain_plot, or_20p_gain_plot, or_20q_gain_plot, or_21q_gain_plot, or_21q_gain_plot, or_22q_gain_plot, ncol = 1)


#Plot second 20 HR plots on one panel
combined_hr_loss_plot_part2 <- plot_grid(or_11p_loss_plot, or_11q_loss_plot, or_12p_loss_plot, or_12q_loss_plot, or_13q_loss_plot, or_14q_loss_plot, or_15q_loss_plot, or_16p_loss_plot, or_16q_loss_plot, or_17p_loss_plot, or_17q_loss_plot, or_18p_loss_plot, or_18q_loss_plot, or_19p_loss_plot, or_19q_loss_plot, or_20p_loss_plot, or_20q_loss_plot, or_21q_loss_plot, or_21q_loss_plot, or_22q_loss_plot, ncol = 1)


```{r}
#Now we need to generate KMC curves comparing IG at 50%

#First do it for the 50% threshold (sheet and IG already calculated previously)
ig_50_kmc <- integrated_grade_50[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_50_kmc <- ig_50_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_50_kmc %>% filter(is.na(sample_short)))

ig_50_kmc$primary.y <- as.numeric(ig_50_kmc$primary.y)
ig_50_kmc$priorRT <- as.numeric(ig_50_kmc$priorRT)
ig_50_kmc$GTR <- as.numeric(ig_50_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR and have at least 6 mo of follow-up
ig_50_kmc_test <- ig_50_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_50_kmc_test <- ig_50_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_50_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_50_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_50_survival <- ggsurvplot(
  km_fit,
  data = ig_50_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
#Lets try it for IG at 5% threshold

#First do it for the 5% threshold (sheet and IG already calculated previously)
ig_5_kmc <- integrated_grade_5[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_5_kmc <- ig_5_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_5_kmc %>% filter(is.na(sample_short)))

ig_5_kmc$primary.y <- as.numeric(ig_5_kmc$primary.y)
ig_5_kmc$priorRT <- as.numeric(ig_5_kmc$priorRT)
ig_5_kmc$GTR <- as.numeric(ig_5_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_5_kmc_test <- ig_5_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_5_kmc_test <- ig_5_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_5_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_5_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_5_survival <- ggsurvplot(
  km_fit,
  data = ig_5_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
#Lets do it for all preset thresholds that we looked at: next is 25%

#First do it for the 25% threshold (sheet and IG already calculated previously)
ig_25_kmc <- integrated_grade_25[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_25_kmc <- ig_25_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_25_kmc %>% filter(is.na(sample_short)))

ig_25_kmc$primary.y <- as.numeric(ig_25_kmc$primary.y)
ig_25_kmc$priorRT <- as.numeric(ig_25_kmc$priorRT)
ig_25_kmc$GTR <- as.numeric(ig_25_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_25_kmc_test <- ig_25_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_25_kmc_test <- ig_25_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_25_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_25_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_25_survival <- ggsurvplot(
  km_fit,
  data = ig_25_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
#Lets do it for all preset thresholds that we looked at: next is 75%

#First do it for the 75% threshold (sheet and IG already calculated previously)
ig_75_kmc <- integrated_grade_75[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_75_kmc <- ig_75_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_75_kmc %>% filter(is.na(sample_short)))

ig_75_kmc$primary.y <- as.numeric(ig_75_kmc$primary.y)
ig_75_kmc$priorRT <- as.numeric(ig_75_kmc$priorRT)
ig_75_kmc$GTR <- as.numeric(ig_75_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_75_kmc_test <- ig_75_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_75_kmc_test <- ig_75_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_75_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_75_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_75_survival <- ggsurvplot(
  km_fit,
  data = ig_75_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
#Lets do it for all preset thresholds that we looked at: next is 95%

#First do it for the 95% threshold (sheet and IG already calculated previously)
ig_95_kmc <- integrated_grade_95[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_95_kmc <- ig_95_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_95_kmc %>% filter(is.na(sample_short)))

ig_95_kmc$primary.y <- as.numeric(ig_95_kmc$primary.y)
ig_95_kmc$priorRT <- as.numeric(ig_95_kmc$priorRT)
ig_95_kmc$GTR <- as.numeric(ig_95_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_95_kmc_test <- ig_95_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_95_kmc_test <- ig_95_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_95_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_95_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_95_survival <- ggsurvplot(
  km_fit,
  data = ig_95_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
#Calculating IG at threshold that was max between 5%-95%
#1p = 46%, 3p = 81%, 4p = 64%, 4q = 59%, 6p = 87%, 6q = 85%, 10p = 10%, 10q = 23%, 14q = 80%, 18p = 63%, 18q = 87%, 19p = 73%, 19q = 50%

integrated_grade_opt_restrict <- integrated_grade

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "1p")) {
      if (any(sample_rows$Chr_Arm == "1p" & sample_rows$total_arm_pct >= 46)) {
        col_name <- "1p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "1p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}  

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "3p")) {
      if (any(sample_rows$Chr_Arm == "3p" & sample_rows$total_arm_pct >= 81)) {
        col_name <- "3p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "3p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "4p")) {
      if (any(sample_rows$Chr_Arm == "4p" & sample_rows$total_arm_pct >= 64)) {
        col_name <- "4p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "4p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "4q")) {
      if (any(sample_rows$Chr_Arm == "4q" & sample_rows$total_arm_pct >= 59)) {
        col_name <- "4q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "4q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "6p")) {
      if (any(sample_rows$Chr_Arm == "6p" & sample_rows$total_arm_pct >= 87)) {
        col_name <- "6p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "6p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample) 
  if (any(sample_rows$Chr_Arm == "6q")) {
      if (any(sample_rows$Chr_Arm == "6q" & sample_rows$total_arm_pct >= 85)) {
        col_name <- "6q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "6q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "10p")) {
      if (any(sample_rows$Chr_Arm == "10p" & sample_rows$total_arm_pct >= 10)) {
        col_name <- "10p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "10p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
} 

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "10q")) {
      if (any(sample_rows$Chr_Arm == "10q" & sample_rows$total_arm_pct >= 23)) {
        col_name <- "10q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "10q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "14q")) {
      if (any(sample_rows$Chr_Arm == "14q" & sample_rows$total_arm_pct >= 80)) {
        col_name <- "14q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "14q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "18p")) {
      if (any(sample_rows$Chr_Arm == "18p" & sample_rows$total_arm_pct >= 63)) {
        col_name <- "18p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "18p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
} 

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "18q")) {
      if (any(sample_rows$Chr_Arm == "18q" & sample_rows$total_arm_pct >= 87)) {
        col_name <- "18q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "18q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "19p")) {
      if (any(sample_rows$Chr_Arm == "19p" & sample_rows$total_arm_pct >= 73)) {
        col_name <- "19p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "19p"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt_restrict$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "19q")) {
      if (any(sample_rows$Chr_Arm == "19q" & sample_rows$total_arm_pct >= 50)) {
        col_name <- "19q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 1
      } else {
        col_name <- "19q"
        integrated_grade_opt_restrict[integrated_grade_opt_restrict$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

#Filter some NA rows
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))

#Combine the Integrated Grade arm calls

integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

#Calculate Integrated Grade
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

#Remove duplicates
integrated_grade_opt_restrict <- integrated_grade_opt_restrict %>% distinct(sample_short, .keep_all = TRUE)





#Calculating IG at max threshold regardless of value
#1p = 46%, 3p = 4%, 4p = 64%, 4q = 96%, 6p = 96%, 6q = 98%, 10p = 10%, 10q = 23%, 14q = 98%, 18p = 63%, 18q = 87%, 19p = 73%, 19q = 50%

integrated_grade_opt <- integrated_grade

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "1p")) {
      if (any(sample_rows$Chr_Arm == "1p" & sample_rows$total_arm_pct >= 46)) {
        col_name <- "1p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "1p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}  

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "3p")) {
      if (any(sample_rows$Chr_Arm == "3p" & sample_rows$total_arm_pct >= 4)) {
        col_name <- "3p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "3p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "4p")) {
      if (any(sample_rows$Chr_Arm == "4p" & sample_rows$total_arm_pct >= 64)) {
        col_name <- "4p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "4p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "4q")) {
      if (any(sample_rows$Chr_Arm == "4q" & sample_rows$total_arm_pct >= 96)) {
        col_name <- "4q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "4q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}
  
for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "6p")) {
      if (any(sample_rows$Chr_Arm == "6p" & sample_rows$total_arm_pct >= 96)) {
        col_name <- "6p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "6p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample) 
  if (any(sample_rows$Chr_Arm == "6q")) {
      if (any(sample_rows$Chr_Arm == "6q" & sample_rows$total_arm_pct >= 98)) {
        col_name <- "6q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "6q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "10p")) {
      if (any(sample_rows$Chr_Arm == "10p" & sample_rows$total_arm_pct >= 10)) {
        col_name <- "10p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "10p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
} 

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "10q")) {
      if (any(sample_rows$Chr_Arm == "10q" & sample_rows$total_arm_pct >= 23)) {
        col_name <- "10q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "10q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "14q")) {
      if (any(sample_rows$Chr_Arm == "14q" & sample_rows$total_arm_pct >= 98)) {
        col_name <- "14q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "14q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "18p")) {
      if (any(sample_rows$Chr_Arm == "18p" & sample_rows$total_arm_pct >= 63)) {
        col_name <- "18p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "18p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
} 

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "18q")) {
      if (any(sample_rows$Chr_Arm == "18q" & sample_rows$total_arm_pct >= 87)) {
        col_name <- "18q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "18q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "19p")) {
      if (any(sample_rows$Chr_Arm == "19p" & sample_rows$total_arm_pct >= 73)) {
        col_name <- "19p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "19p"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

for (sample in integrated_grade_opt$Sample) {
  sample_rows <- noncont_arm_loss_samples %>% 
    filter(Sample == sample)
  
  if (any(sample_rows$Chr_Arm == "19q")) {
      if (any(sample_rows$Chr_Arm == "19q" & sample_rows$total_arm_pct >= 50)) {
        col_name <- "19q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 1
      } else {
        col_name <- "19q"
        integrated_grade_opt[integrated_grade_opt$Sample == sample, col_name] <- 0
      }
  } else {
    # Move on to the next sample
      next
  }
}

#Filter some NA rows
integrated_grade_opt <- integrated_grade_opt %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))

#Combine the Integrated Grade arm calls

integrated_grade_opt <- integrated_grade_opt %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
integrated_grade_opt <- integrated_grade_opt %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
integrated_grade_opt <- integrated_grade_opt %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
integrated_grade_opt <- integrated_grade_opt %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
integrated_grade_opt <- integrated_grade_opt %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))

#Calculate Integrated Grade
integrated_grade_opt <- integrated_grade_opt %>% mutate(score = rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
integrated_grade_opt <- integrated_grade_opt %>% mutate(ig = ifelse(score <= 1, 1, ifelse(score >= 2 & score <= 3, 2, 3)))

#Remove duplicates
integrated_grade_opt <- integrated_grade_opt %>% distinct(sample_short, .keep_all = TRUE)

```


```{r}
#Now lets check survival for the optimal IG with thresholds within 5-95%

#Do it for the opt_restrict threshold (sheet and IG already calculated previously)
ig_opt_restrict_kmc <- integrated_grade_opt_restrict[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_opt_restrict_kmc <- ig_opt_restrict_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_opt_restrict_kmc %>% filter(is.na(sample_short)))

ig_opt_restrict_kmc$primary.y <- as.numeric(ig_opt_restrict_kmc$primary.y)
ig_opt_restrict_kmc$priorRT <- as.numeric(ig_opt_restrict_kmc$priorRT)
ig_opt_restrict_kmc$GTR <- as.numeric(ig_opt_restrict_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_opt_restrict_kmc_test <- ig_opt_restrict_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_opt_restrict_kmc_test <- ig_opt_restrict_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_opt_restrict_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_opt_restrict_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_opt_restrict_survival <- ggsurvplot(
  km_fit,
  data = ig_opt_restrict_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```


```{r}
#Now lets check survival for the optimal IG threshold

#Do it for the opt threshold (sheet and IG already calculated previously)
ig_opt_kmc <- integrated_grade_opt[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_opt_kmc <- ig_opt_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_opt_kmc %>% filter(is.na(sample_short)))

ig_opt_kmc$primary.y <- as.numeric(ig_opt_kmc$primary.y)
ig_opt_kmc$priorRT <- as.numeric(ig_opt_kmc$priorRT)
ig_opt_kmc$GTR <- as.numeric(ig_opt_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_opt_kmc_test <- ig_opt_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_opt_kmc_test <- ig_opt_kmc_test %>% filter(months_lastfu >= 6)

#KMC curve for PFS

surv_object <- with(ig_opt_kmc_test, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ ig, data = ig_opt_kmc_test)
custom_palette <- c("dodgerblue4", "chartreuse4", "firebrick2")

ig_opt_survival <- ggsurvplot(
  km_fit,
  data = ig_opt_kmc_test,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Progression Status",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("IG 1", "IG 2", "IG 3"),
  palette = custom_palette
)

```

```{r}
# Creating alternate KMC comparison which looks specifically at the differences between thresholds at each IG grade (plotting each IG grade on a seperate plot, total of 3 plots)

# Create IG dataframes
ig_5_kmc_test_ig1 <- ig_5_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 5)
ig_25_kmc_test_ig1 <- ig_25_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 25)
ig_50_kmc_test_ig1 <- ig_50_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 50)
ig_75_kmc_test_ig1 <- ig_75_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 75)
ig_95_kmc_test_ig1 <- ig_95_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 95)
ig_opt_kmc_test_ig1 <- ig_opt_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 100)

ig1_threshold_kmc <- bind_rows(ig_5_kmc_test_ig1, ig_25_kmc_test_ig1, ig_50_kmc_test_ig1, ig_75_kmc_test_ig1, ig_95_kmc_test_ig1, ig_opt_kmc_test_ig1)

ig1_threshold_kmc <- bind_rows(ig_5_kmc_test_ig1, ig_25_kmc_test_ig1, ig_50_kmc_test_ig1, ig_75_kmc_test_ig1, ig_95_kmc_test_ig1)

ig1_threshold_kmc <- bind_rows(ig_5_kmc_test_ig1, ig_50_kmc_test_ig1, ig_95_kmc_test_ig1, ig_opt_kmc_test_ig1)

ig_5_kmc_test_ig2 <- ig_5_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 5)
ig_25_kmc_test_ig2 <- ig_25_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 25)
ig_50_kmc_test_ig2 <- ig_50_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 50)
ig_75_kmc_test_ig2 <- ig_75_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 75)
ig_95_kmc_test_ig2 <- ig_95_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 95)
ig_opt_kmc_test_ig2 <- ig_opt_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 100)

ig2_threshold_kmc <- bind_rows(ig_5_kmc_test_ig2, ig_25_kmc_test_ig2, ig_50_kmc_test_ig2, ig_75_kmc_test_ig2, ig_95_kmc_test_ig2, ig_opt_kmc_test_ig2)

ig2_threshold_kmc <- bind_rows(ig_5_kmc_test_ig2, ig_25_kmc_test_ig2, ig_50_kmc_test_ig2, ig_75_kmc_test_ig2, ig_95_kmc_test_ig2)

ig2_threshold_kmc <- bind_rows(ig_5_kmc_test_ig2, ig_50_kmc_test_ig2, ig_95_kmc_test_ig2, ig_opt_kmc_test_ig2)

ig_5_kmc_test_ig3 <- ig_5_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 5)
ig_25_kmc_test_ig3 <- ig_25_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 25)
ig_50_kmc_test_ig3 <- ig_50_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 50)
ig_75_kmc_test_ig3 <- ig_75_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 75)
ig_95_kmc_test_ig3 <- ig_95_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 95)
ig_opt_kmc_test_ig3 <- ig_opt_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 100)

ig3_threshold_kmc <- bind_rows(ig_5_kmc_test_ig3, ig_25_kmc_test_ig3, ig_50_kmc_test_ig3, ig_75_kmc_test_ig3, ig_95_kmc_test_ig3, ig_opt_kmc_test_ig3)

ig3_threshold_kmc <- bind_rows(ig_5_kmc_test_ig3, ig_25_kmc_test_ig3, ig_50_kmc_test_ig3, ig_75_kmc_test_ig3, ig_95_kmc_test_ig3)

ig3_threshold_kmc <- bind_rows(ig_5_kmc_test_ig3, ig_50_kmc_test_ig3, ig_95_kmc_test_ig3, ig_opt_kmc_test_ig3)


#IG1 KMC curve for PFS
surv_object <- with(ig1_threshold_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig1_threshold_kmc)

ig1_thresholds_survival <- ggsurvplot(
  km_fit,
  data = ig1_threshold_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("5", "25", "50", "75", "95"), #c("5", "50", "95", "Opt"), #c("5", "25", "50", "75", "95", "Opt")
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)

#IG2 KMC curve for PFS
surv_object <- with(ig2_threshold_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig2_threshold_kmc)

ig2_thresholds_survival <- ggsurvplot(
  km_fit,
  data = ig2_threshold_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("5", "25", "50", "75", "95"), #c("5", "50", "95", "Opt"), #c("5", "25", "50", "75", "95", "Opt")
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)


#IG3 KMC curve for PFS
surv_object <- with(ig3_threshold_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig3_threshold_kmc)

ig3_thresholds_survival <- ggsurvplot(
  km_fit,
  data = ig3_threshold_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("5", "25", "50", "75", "95"), #c("5", "50", "95", "Opt"), #c("5", "25", "50", "75", "95", "Opt")
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)


```


```{r}
#Now lets do a KMC comparison for the absolute thresholds

#First do it for the 3 Mb threshold
ig_3abs_kmc <- integrated_grade_3abs[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_3abs_kmc <- ig_3abs_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_3abs_kmc %>% filter(is.na(sample_short)))

ig_3abs_kmc$primary.y <- as.numeric(ig_3abs_kmc$primary.y)
ig_3abs_kmc$priorRT <- as.numeric(ig_3abs_kmc$priorRT)
ig_3abs_kmc$GTR <- as.numeric(ig_3abs_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_3abs_kmc_test <- ig_3abs_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_3abs_kmc_test <- ig_3abs_kmc_test %>% filter(months_lastfu >= 6)

```

```{r}
#First do it for the 6 Mb threshold (sheet and IG already calculated previously)
ig_6abs_kmc <- integrated_grade_6abs[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_6abs_kmc <- ig_6abs_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_6abs_kmc %>% filter(is.na(sample_short)))

ig_6abs_kmc$primary.y <- as.numeric(ig_6abs_kmc$primary.y)
ig_6abs_kmc$priorRT <- as.numeric(ig_6abs_kmc$priorRT)
ig_6abs_kmc$GTR <- as.numeric(ig_6abs_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_6abs_kmc_test <- ig_6abs_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_6abs_kmc_test <- ig_6abs_kmc_test %>% filter(months_lastfu >= 6)

```

```{r}
#First do it for the 9 Mb threshold (sheet and IG already calculated previously)
ig_9abs_kmc <- integrated_grade_9abs[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_9abs_kmc <- ig_9abs_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_9abs_kmc %>% filter(is.na(sample_short)))

ig_9abs_kmc$primary.y <- as.numeric(ig_9abs_kmc$primary.y)
ig_9abs_kmc$priorRT <- as.numeric(ig_9abs_kmc$priorRT)
ig_9abs_kmc$GTR <- as.numeric(ig_9abs_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_9abs_kmc_test <- ig_9abs_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_9abs_kmc_test <- ig_9abs_kmc_test %>% filter(months_lastfu >= 6)

```

```{r}
#First do it for the 12 Mb threshold (sheet and IG already calculated previously)
ig_12abs_kmc <- integrated_grade_12abs[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_12abs_kmc <- ig_12abs_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_12abs_kmc %>% filter(is.na(sample_short)))

ig_12abs_kmc$primary.y <- as.numeric(ig_12abs_kmc$primary.y)
ig_12abs_kmc$priorRT <- as.numeric(ig_12abs_kmc$priorRT)
ig_12abs_kmc$GTR <- as.numeric(ig_12abs_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_12abs_kmc_test <- ig_12abs_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_12abs_kmc_test <- ig_12abs_kmc_test %>% filter(months_lastfu >= 6)

```


```{r}
#First do it for the 15 Mb threshold (sheet and IG already calculated previously)
ig_15abs_kmc <- integrated_grade_15abs[, c("Sample", "sample_short", "recur", "ig")]

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate
ig_15abs_kmc <- ig_15abs_kmc %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(ig_15abs_kmc %>% filter(is.na(sample_short)))

ig_15abs_kmc$primary.y <- as.numeric(ig_15abs_kmc$primary.y)
ig_15abs_kmc$priorRT <- as.numeric(ig_15abs_kmc$priorRT)
ig_15abs_kmc$GTR <- as.numeric(ig_15abs_kmc$GTR)

#Select rows that are only primary, nonradiated, GTR
ig_15abs_kmc_test <- ig_15abs_kmc %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
ig_15abs_kmc_test <- ig_15abs_kmc_test %>% filter(months_lastfu >= 6)

```

```{r}
# Creating alternate KMC comparison which looks specifically at the differences between absolute thresholds at each IG grade (plotting each IG grade on a seperate plot, total of 3 plots)

# Create IG dataframes
ig_3abs_kmc_test_ig1 <- ig_3abs_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 3)
ig_6abs_kmc_test_ig1 <- ig_6abs_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 6)
ig_9abs_kmc_test_ig1 <- ig_9abs_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 9)
ig_12abs_kmc_test_ig1 <- ig_12abs_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 12)
ig_15abs_kmc_test_ig1 <- ig_15abs_kmc_test %>% filter(ig == 1) %>% mutate(thresh = 15)

ig1_threshold_abs_kmc <- bind_rows(ig_3abs_kmc_test_ig1, ig_6abs_kmc_test_ig1, ig_9abs_kmc_test_ig1, ig_12abs_kmc_test_ig1, ig_15abs_kmc_test_ig1)


ig_3abs_kmc_test_ig2 <- ig_3abs_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 3)
ig_6abs_kmc_test_ig2 <- ig_6abs_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 6)
ig_9abs_kmc_test_ig2 <- ig_9abs_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 9)
ig_12abs_kmc_test_ig2 <- ig_12abs_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 12)
ig_15abs_kmc_test_ig2 <- ig_15abs_kmc_test %>% filter(ig == 2) %>% mutate(thresh = 15)

ig2_threshold_abs_kmc <- bind_rows(ig_5_kmc_test_ig2, ig_6abs_kmc_test_ig2, ig_9abs_kmc_test_ig2, ig_12abs_kmc_test_ig2, ig_15abs_kmc_test_ig2)


ig_3abs_kmc_test_ig3 <- ig_3abs_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 3)
ig_6abs_kmc_test_ig3 <- ig_6abs_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 6)
ig_9abs_kmc_test_ig3 <- ig_9abs_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 9)
ig_12abs_kmc_test_ig3 <- ig_12abs_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 12)
ig_15abs_kmc_test_ig3 <- ig_15abs_kmc_test %>% filter(ig == 3) %>% mutate(thresh = 15)

ig3_threshold_abs_kmc <- bind_rows(ig_3abs_kmc_test_ig3, ig_6abs_kmc_test_ig3, ig_9abs_kmc_test_ig3, ig_12abs_kmc_test_ig3, ig_15abs_kmc_test_ig3)


#IG1 KMC curve for PFS
surv_object <- with(ig1_threshold_abs_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig1_threshold_abs_kmc)

ig1_thresholds_abs_survival <- ggsurvplot(
  km_fit,
  data = ig1_threshold_abs_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("3", "6", "9", "12", "15"),
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)

#IG2 KMC curve for PFS
surv_object <- with(ig2_threshold_abs_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig2_threshold_abs_kmc)

ig2_thresholds_abs_survival <- ggsurvplot(
  km_fit,
  data = ig2_threshold_abs_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("3", "6", "9", "12", "15"),
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)

#IG3 KMC curve for PFS
surv_object <- with(ig3_threshold_abs_kmc, Surv(months_rec_fu, event = recur_RP))
km_fit <- survfit(surv_object ~ thresh, data = ig3_threshold_abs_kmc)

ig3_thresholds_abs_survival <- ggsurvplot(
  km_fit,
  data = ig3_threshold_abs_kmc,
  pval = TRUE,
  conf.int = FALSE,
  risk.table = "nrisk_cumcensor",
  risk.table.title = "Num. at Risk (Num. Censored)",
  xlab = "Time (Months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Curves for Progression-Free Survival",
  legend.labs = c("3", "6", "9", "12", "15"),
  palette = "Dark2",
  ggtheme = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), axis.ticks = element_blank()) + theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), axis.text = element_text(size=18), text = element_text(size = 14))
)

```

```{r}
#To generate time-dependent ROC, time-dependent AP, and time-dependent Brier prediction curves to discrimination and calibration of IG across thresholds from 0 to 100, we need to generate IG classification across all thresholds

#First we need to generate a datasheet that has recurrence info, time to recurrence, and IG grades at various thresholds in the sheet

#Calls for all thresholds
#Initialize datasheet to collect everything
integrated_grade_iterate <- integrated_grade
integrated_grade_iterate <- integrated_grade_iterate %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
integrated_grade_iterate <- integrated_grade_iterate %>% select(Sample, sample_short, recur)
integrated_grade_iterate_1p <- integrated_grade_iterate

# Iterate through thresholds from 0 to 100 in increments of 1
for (threshold in 0:100) {
  
  # Create a copy of the original integrated_grade dataframe
  integrated_grade_x <- integrated_grade
  
  # Loop through Samples
  for (i in 1:nrow(noncont_arm_loss_samples)) {
    sample_name <- noncont_arm_loss_samples$Sample[i]
    total_arm_pct <- noncont_arm_loss_samples$total_arm_pct[i]
    chr_arm <- noncont_arm_loss_samples$Chr_Arm[i]
    
    # Find the row in integrated_grade_x that matches the sample name
    row_index <- which(integrated_grade_x$Sample == sample_name)
    
    # If total_arm_pct is greater than or equal to the current threshold, update the corresponding column
    if (!is.na(row_index) && total_arm_pct >= threshold) {
      integrated_grade_x[row_index, chr_arm] <- 1
    }
  }
  
  # Get the index of the last chromosome column
  index_19q <- which(colnames(integrated_grade_x) == "19q")
  
  # Subset the dataframe to keep columns up to the last chromosome column
  integrated_grade_x <- integrated_grade_x[, 1:index_19q]
  
  # Filter Rows
  integrated_grade_x <- integrated_grade_x %>% filter(!is.na(mitoses_binned)) %>% filter(!is.na(CDKN2A)) %>% filter(!is.na(recur))
  
  # Create New Columns
  integrated_grade_x <- integrated_grade_x %>% mutate(`4p_q` = ifelse(`4p` == 1 | `4q` == 1, 1, 0))
  integrated_grade_x <- integrated_grade_x %>% mutate(`6p_q` = ifelse(`6p` == 1 | `6q` == 1, 1, 0))
  integrated_grade_x <- integrated_grade_x %>% mutate(`10p_q` = ifelse(`10p` == 1 | `10q` == 1, 1, 0))
  integrated_grade_x <- integrated_grade_x %>% mutate(`18p_q` = ifelse(`18p` == 1 | `18q` == 1, 1, 0))
  integrated_grade_x <- integrated_grade_x %>% mutate(`19p_q` = ifelse(`19p` == 1 | `19q` == 1, 1, 0))
  
  # Rename the score and ig columns
  col_name_score <- paste0("score_", threshold)
  col_name_ig <- paste0("ig_", threshold)
  
  #Calculate Integrated Grade
  integrated_grade_x <- integrated_grade_x %>% mutate(!!col_name_score := rowSums(select(., CDKN2A, mitoses_binned, `1p`, `3p`, `4p_q`, `6p_q`, `10p_q`, `14q`, `18p_q`, `19p_q`), na.rm = TRUE))
  integrated_grade_x <- integrated_grade_x %>% mutate(!!col_name_ig := ifelse(!!col_name_score <= 1, 1, ifelse(!!col_name_score >= 2 & !!col_name_score <= 3, 2, 3)))
  
  #Rename 1p column by threshold
  col_name_1p <- paste0("1p_", threshold)
  integrated_grade_x <- integrated_grade_x %>% rename(!!col_name_1p := `1p`)
  
  #Remove duplicate samples
  integrated_grade_x <- integrated_grade_x %>% distinct(sample_short, .keep_all = TRUE)
  
  print(threshold)
  
  integrated_grade_iterate <- left_join(integrated_grade_iterate, integrated_grade_x %>% select(Sample, !!col_name_score), by = "Sample")
  integrated_grade_iterate_1p <- left_join(integrated_grade_iterate_1p, integrated_grade_x %>% select(Sample, !!col_name_1p), by = "Sample")
}

integrated_grade_iterate <- integrated_grade_iterate %>% distinct(sample_short, .keep_all = TRUE)
integrated_grade_iterate_1p <- integrated_grade_iterate_1p %>% distinct(sample_short, .keep_all = TRUE)

#Convert the score counts to integrated grade
integrated_grade_iterate <- integrated_grade_iterate %>% mutate_at(vars(starts_with("score_")), ~ case_when(. <= 1 ~ 1, . >= 2 & . <= 3 ~ 2, TRUE ~ 3))


#Merge in data on primary, GTR, no radiation to select appropriate rows

#Merge in information on primary, prior RT, GTR, DOS, recdate_ifnorecurthen_lastfudate. Going to add WHO grade as well so that we can do error calculation for that as well
integrated_grade_iterate <- integrated_grade_iterate %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu, Grade), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_iterate %>% filter(is.na(sample_short)))

integrated_grade_iterate_1p <- integrated_grade_iterate_1p %>% filter(!is.na(sample_short)) %>% left_join(unique_mening_master %>% select(CG_merged, primary.y, priorRT, GTR, recur_RP, months_rec_fu, months_lastfu), by = c("sample_short" = "CG_merged")) %>% bind_rows(integrated_grade_iterate_1p %>% filter(is.na(sample_short)))

integrated_grade_iterate$primary.y <- as.numeric(integrated_grade_iterate$primary.y)
integrated_grade_iterate$priorRT <- as.numeric(integrated_grade_iterate$priorRT)
integrated_grade_iterate$GTR <- as.numeric(integrated_grade_iterate$GTR)

integrated_grade_iterate_1p$primary.y <- as.numeric(integrated_grade_iterate_1p$primary.y)
integrated_grade_iterate_1p$priorRT <- as.numeric(integrated_grade_iterate_1p$priorRT)
integrated_grade_iterate_1p$GTR <- as.numeric(integrated_grade_iterate_1p$GTR)

#Select rows that are only primary, nonradiated, GTR with at least 6 mo of follow up
integrated_grade_iterate <- integrated_grade_iterate %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
integrated_grade_iterate <- integrated_grade_iterate %>% filter(months_lastfu >= 6)

integrated_grade_iterate_1p <- integrated_grade_iterate_1p %>% filter(primary.y == 1, priorRT == 0, GTR == 1)
integrated_grade_iterate_1p <- integrated_grade_iterate_1p %>% filter(months_lastfu >= 6)

```

```{r}
#Now we're going to generate time-dependent ROC, time-dependent AP, and time-dependent Brier prediction curves to discrimination and calibration of IG across thresholds from 0 to 100.
library(timeROC)
library(APtools)

#Add in optimal IG threshold values as score_101...removing this for now because not including optimal IG as part of final manuscipt
#integrated_grade_iterate <- left_join(integrated_grade_iterate, ig_opt_kmc_test %>% select(sample_short, ig), by = "sample_short") %>% rename(score_101 = ig)

# Assuming the data frame is integrated_grade_iterate
data <- integrated_grade_iterate

data_auc <- data.frame(time = 6:96)

for (threshold in 0:100) {
  col_name_score <- paste0("score_", threshold)
  roc_result <- timeROC(T=data$months_rec_fu, delta=data$recur_RP, marker = data[[col_name_score]], cause=1, times=seq(6, 96, by = 1))
  
  auc_list <- as.data.frame(roc_result$AUC)
  
  # Add values to data_auc
  data_auc <- cbind(data_auc, auc_list)

}


colnames(data_auc) <- c("time", paste0(0:100, "_AUC"))
data_auc[data_auc$time == 0, -1] <- 1

data_long <- gather(data_auc, key = "series", value = "value", -time)
data_long$series <- factor(data_long$series, levels = paste0(0:100, "_AUC"), ordered = TRUE)

all_auc <- ggplot(data_long, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none")

# Select only the desired columns
selected_columns <- c("5_AUC", "25_AUC", "50_AUC", "75_AUC", "95_AUC", "98_AUC")
filtered_data_long <- data_long[data_long$series %in% selected_columns, ]

# Plot using ggplot2 with selected columns
selected_auc_plot <- ggplot(filtered_data_long, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 
  



#Plotting out average precision
#Assuming the data frame is integrated_grade_iterate
data <- integrated_grade_iterate

data_ap <- data.frame(time = 6:96)

for (threshold in 0:100) {
  col_name_score <- paste0("score_", threshold)
  ap_result <- APSurv(stime = data$months_rec_fu, status = data$recur_RP, marker = data[[col_name_score]], t0.list = seq(6, 96, by = 1))
  
  ap_list <- as.data.frame(ap_result$ap_summary)
  ap_list <- ap_list$`AP(t)`
  
  # Add values to data_auc
  data_ap <- cbind(data_ap, ap_list)
  print(threshold)

}

colnames(data_ap) <- c("time", paste0(0:100, "_AP"))
data_ap[data_auc$time == 0, -1] <- 0

data_long_ap <- gather(data_ap, key = "series", value = "value", -time)
data_long_ap$series <- factor(data_long_ap$series, levels = paste0(0:101, "_AP"), ordered = TRUE)

all_ap <- ggplot(data_long_ap, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1), breaks = seq(0, 1, 0.25)) + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none")

# Select only the desired columns
selected_columns_ap <- c("5_AP", "25_AP", "50_AP", "75_AP", "95_AP", "98_AP")
filtered_data_long_ap <- data_long_ap[data_long_ap$series %in% selected_columns_ap, ]

# Plot using ggplot2 with selected columns
selected_ap_plot <- ggplot(filtered_data_long_ap, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1), breaks = seq(0, 1, 0.25)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 
  


#Trying to generete Brier curves now
ig_filtered <- integrated_grade_iterate
time_list <- seq(6, 96, by = 1)
data_brier <- data.frame(time = 6:96)

for (threshold in 0:100) {
  col_name_score <- paste0("score_", threshold)
  formula_string <- paste("Surv(months_rec_fu, recur_RP)~", col_name_score)
  Cox_new=coxph(as.formula(formula_string),data=ig_filtered,x=TRUE,y=TRUE)

  brier_results <- brier(fit=Cox_new, times=time_list)
  brier_format <- as.data.frame(brier_results)
  brier_format[[col_name_score]] <- brier_format$brier
  cols_to_remove <- c("rsquared", "brier", "times")

  brier_format <- select(brier_format, -one_of(cols_to_remove))
  
  # Add values to data_auc
  data_brier <- cbind(data_brier, brier_format)
  print(threshold)

}

data_long_brier <- gather(data_brier, key = "series", value = "value", -time)
data_long_brier$series <- factor(data_long_brier$series, levels = paste0("score_", 0:100), ordered = TRUE)

all_brier <- ggplot(data_long_brier, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Brier PE Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.2), breaks = seq(0, 0.2, 0.05)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none") 

# Select only the desired columns
selected_columns_brier <- c("score_5", "score_25", "score_50", "score_75", "score_95", "score_98")
filtered_data_long_brier <- data_long_brier[data_long_brier$series %in% selected_columns_brier, ]

# Plot using ggplot2 with selected columns
selected_brier_plot <- ggplot(filtered_data_long_brier, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.2), breaks = seq(0, 0.2, 0.05)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 

```


```{r}
#Extracting some stats from the previous code chunk to figure out if there is a threshold we want to pick/what works the best in the IG classifier

#Finding the threshold with the max AUC at a given timepoint

row_index <- which(data_auc$time == 36) #Adjust based on month timepoint you want to look at

# Extract the values in that row (excluding the "time" column)
row_values <- data_auc[row_index, -which(names(data_auc) == "time")]

# Find the column name with the maximum value in the specified row
max_column <- names(data_auc)[-which(names(data_auc) == "time")][which.max(row_values)]
min_column <- names(data_auc)[-which(names(data_auc) == "time")][which.min(row_values)]

#Calculate the area of the time-dependent AUC curve
library(pracma)

# Create an empty data frame to store the area under the curve for each series
area_df <- data.frame(series = character(), area_under_curve = numeric())

# Iterate over series columns (assuming they are in sequential order)
for (series_col in grep("^\\d+_AUC$", names(data_auc), value = TRUE)) {
  # Extract the series data
  series_data <- data_auc[c("time", series_col)]
  
  # Use the trapz function to calculate the area under the curve
  area <- trapz(series_data$time, series_data[[series_col]])
  
  # Append the result to the area_df data frame
  area_df <- rbind(area_df, data.frame(series = series_col, area_under_curve = area))
}



#Calculate the area of the time-dependent AP curve
library(pracma)

# Create an empty data frame to store the area under the curve for each series
area_ap_df <- data.frame(series = character(), area_under_curve = numeric())

# Iterate over series columns (assuming they are in sequential order)
for (series_col in grep("^\\d+_AP$", names(data_ap), value = TRUE)) {
  # Extract the series data
  series_data <- data_ap[c("time", series_col)]
  
  # Use the trapz function to calculate the area under the curve
  area <- trapz(series_data$time, series_data[[series_col]])
  
  # Append the result to the area_df data frame
  area_ap_df <- rbind(area_ap_df, data.frame(series = series_col, area_under_curve = area))
}


#Calculate the area of the Brier
library(pracma)

# Create an empty data frame to store the area under the curve for each series
area_brier_df <- data.frame(series = character(), area_under_curve = numeric())

# Iterate over series columns (assuming they are in sequential order)
for (series_col in grep("^score_\\d+$", names(data_brier), value = TRUE)) {
  # Extract the series data
  series_data <- data_brier[c("time", series_col)]
  
  # Use the trapz function to calculate the area under the curve
  area <- trapz(series_data$time, series_data[[series_col]])
  
  # Append the result to the area_df data frame
  area_brier_df <- rbind(area_brier_df, data.frame(series = series_col, area_under_curve = area))
}

```


```{r}
#Doing time-dependent ROC, prediction error analysis for 1p
library(timeROC)
library(APtools)

# Assuming the data frame is integrated_grade_iterate_1p
data <- integrated_grade_iterate_1p

data_auc <- data.frame(time = 6:96)

for (threshold in 0:100) {
  col_name_score <- paste0("1p_", threshold)
  roc_result <- timeROC(T=data$months_rec_fu, delta=data$recur_RP, marker = data[[col_name_score]], cause=1, times=seq(6, 96, by = 1))
  
  auc_list <- as.data.frame(roc_result$AUC)
  
  # Add values to data_auc
  data_auc <- cbind(data_auc, auc_list)

}


colnames(data_auc) <- c("time", paste0(0:100, "_AUC"))
data_auc[data_auc$time == 0, -1] <- 1

data_long <- gather(data_auc, key = "series", value = "value", -time)
data_long$series <- factor(data_long$series, levels = paste0(0:100, "_AUC"), ordered = TRUE)

all_auc <- ggplot(data_long, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none") #

# Select only the desired columns
selected_columns <- c("5_AUC", "25_AUC", "50_AUC", "75_AUC", "85_AUC", "90_AUC", "95_AUC", "97_AUC")
filtered_data_long <- data_long[data_long$series %in% selected_columns, ]

# Plot using ggplot2 with selected columns
selected_auc_plot <- ggplot(filtered_data_long, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 
  



#Plotting out average precision
#Assuming the data frame is integrated_grade_iterate
data <- integrated_grade_iterate_1p

data_ap <- data.frame(time = 6:96)

for (threshold in 0:100) {
  col_name_score <- paste0("1p_", threshold)
  ap_result <- APSurv(stime = data$months_rec_fu, status = data$recur_RP, marker = data[[col_name_score]], t0.list = seq(6, 96, by = 1))
  
  ap_list <- as.data.frame(ap_result$ap_summary)
  ap_list <- ap_list$`AP(t)`
  
  # Add values to data_auc
  data_ap <- cbind(data_ap, ap_list)
  print(threshold)

}

colnames(data_ap) <- c("time", paste0(0:100, "_AP"))
data_ap[data_auc$time == 0, -1] <- 0

data_long_ap <- gather(data_ap, key = "series", value = "value", -time)
data_long_ap$series <- factor(data_long_ap$series, levels = paste0(0:101, "_AP"), ordered = TRUE)

all_ap <- ggplot(data_long_ap, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.5), breaks = seq(0, 1, 0.25)) + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none")

# Select only the desired columns
selected_columns_ap <- c("5_AP", "25_AP", "50_AP", "75_AP", "85_AP", "90_AP", "95_AP", "97_AP")
filtered_data_long_ap <- data_long_ap[data_long_ap$series %in% selected_columns_ap, ]

# Plot using ggplot2 with selected columns
selected_ap_plot <- ggplot(filtered_data_long_ap, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.5), breaks = seq(0, 1, 0.25)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 
  


#Trying to generete Brier curves now
ig_filtered <- integrated_grade_iterate_1p
time_list <- seq(6, 96, by = 1)
data_brier <- data.frame(time = 6:96)

ig_filtered <- ig_filtered %>% rename_with(~paste0("score_", gsub("^1p_", "", .x)), starts_with("1p_"))

for (threshold in 0:100) {
  col_name_score <- paste0("score_", threshold)
  formula_string <- paste("Surv(months_rec_fu, recur_RP)~", col_name_score)
  Cox_new=coxph(as.formula(formula_string),data=ig_filtered,x=TRUE,y=TRUE)

  brier_results <- brier(fit=Cox_new, times=time_list)
  brier_format <- as.data.frame(brier_results)
  brier_format[[col_name_score]] <- brier_format$brier
  cols_to_remove <- c("rsquared", "brier", "times")

  brier_format <- select(brier_format, -one_of(cols_to_remove))
  
  # Add values to data_auc
  data_brier <- cbind(data_brier, brier_format)
  print(threshold)

}

data_long_brier <- gather(data_brier, key = "series", value = "value", -time)
data_long_brier$series <- factor(data_long_brier$series, levels = paste0("score_", 0:100), ordered = TRUE)

all_brier <- ggplot(data_long_brier, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Brier PE Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.2), breaks = seq(0, 0.2, 0.05)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none") 

# Select only the desired columns
selected_columns_brier <- c("score_5", "score_25", "score_50", "score_75", "score_85", "score_90", "score_95", "score_97")
filtered_data_long_brier <- data_long_brier[data_long_brier$series %in% selected_columns_brier, ]

# Plot using ggplot2 with selected columns
selected_brier_plot <- ggplot(filtered_data_long_brier, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_ap Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,0.2), breaks = seq(0, 0.2, 0.05)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 


```


```{r}
#Adding a separate code chunk here to do time-depent AUC calculation while also adding in WHO grade and optimal IG grade

library(timeROC)
library(APtools)

#Add in optimal IG threshold values as score_101...removing this for now because not including optimal IG as part of final manuscipt
integrated_grade_iterate <- left_join(integrated_grade_iterate, ig_opt_kmc_test %>% select(sample_short, ig), by = "sample_short") %>% rename(score_101 = ig)

#Rename the grade column into score_102
integrated_grade_iterate <- integrated_grade_iterate %>% rename(score_102 = Grade)
integrated_grade_iterate$score_101 <- as.numeric(integrated_grade_iterate$score_101)
integrated_grade_iterate$score_102 <- as.numeric(integrated_grade_iterate$score_102)

# Assuming the data frame is integrated_grade_iterate
data <- integrated_grade_iterate

data_auc <- data.frame(time = 6:96)

#Change to 102 if including opt and WHO grades
for (threshold in 0:102) {
  col_name_score <- paste0("score_", threshold)
  roc_result <- timeROC(T=data$months_rec_fu, delta=data$recur_RP, marker = data[[col_name_score]], cause=1, times=seq(6, 96, by = 1))
  
  auc_list <- as.data.frame(roc_result$AUC)
  
  # Add values to data_auc
  data_auc <- cbind(data_auc, auc_list)

}

#Change to 102 if including opt and WHO grades
colnames(data_auc) <- c("time", paste0(0:102, "_AUC"))
data_auc[data_auc$time == 0, -1] <- 1

data_long <- gather(data_auc, key = "series", value = "value", -time)
data_long$series <- factor(data_long$series, levels = paste0(0:102, "_AUC"), ordered = TRUE)

all_auc <- ggplot(data_long, aes(x = time, y = value, color = series)) +
  geom_line() +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18), legend.position = "none")

# Select only the desired columns
selected_columns <- c("5_AUC", "50_AUC", "75_AUC", "95_AUC", "101_AUC", "102_AUC")
filtered_data_long <- data_long[data_long$series %in% selected_columns, ]

# Plot using ggplot2 with selected columns
selected_auc_plot <- ggplot(filtered_data_long, aes(x = time, y = value, color = series)) +
  geom_line(size=1.2) +
  labs(title = "Values in data_auc Over Time",
       x = "Time",
       y = "Value") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0,96,12), limits = c(0,96)) +
  scale_y_continuous(limits=c(0,1.1), breaks = seq(0, 1, 0.2)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), axis.ticks = element_blank(), axis.text = element_text(size=18)) 
  

#Calculate the area of the time-dependent AUC curve
library(pracma)

# Create an empty data frame to store the area under the curve for each series
area_df <- data.frame(series = character(), area_under_curve = numeric())

# Iterate over series columns (assuming they are in sequential order)
for (series_col in grep("^\\d+_AUC$", names(data_auc), value = TRUE)) {
  # Extract the series data
  series_data <- data_auc[c("time", series_col)]
  
  # Use the trapz function to calculate the area under the curve
  area <- trapz(series_data$time, series_data[[series_col]])
  
  # Append the result to the area_df data frame
  area_df <- rbind(area_df, data.frame(series = series_col, area_under_curve = area))
}

```

